[
  {
    "title": "Welcome to BuildShip ‚Äì BuildShip",
    "url": "https://docs.buildship.com",
    "html": "Welcome to BuildShip\nA Low-code Visual Backend Builder, powered by AI ‚ú® Use BuildShip to create:\n\nScalable APIs\nScheduled tasks / CRON jobs\nBackend cloud functions\nDatabase CRUD or event data triggered functions\nWhatsApp, Telegram, Slack, Discord, AI chatbot\n\nBuildShip integrates with any tools like Stripe, Sengrid, Whatsapp or AI model from OpenAI, Replicate etc or database\nlike Firebase, Supabase, Postgres.\nü™© Best part? if any integration is missing, don't get stuck - use AI to generate you own workflow nodes. BuildShip\ngives you the best of no-code with the power of low-code. See the 5 minutes product walkthrough.\n\n \n\nQuick Start\n\nFollow the learning resources below to get a deeper understanding of the platform:\nHow to build a workflow?‚ÜíWhat is a node?‚ÜíWhat are workflow triggers?‚Üí\nYou can connect your favorite AI-models, tools, API services, and backend in minutes. Extend your workflow's\ncapabilities with JavaScript / TypeScript code and 1M+ NPM packages! ü§Ø\nBuildShip lets you build scalable backend workflows for the apps you build on any stack. Be it a no-code app builder\n(FlutterFlow, Webflow, Framer, Adalo, Bubble, BravoStudio ...) or a frontend framework (Next.js, React, Vue ...) - you\ncan build scalable backend tasks for them in minutes. This means you don't need to wrangle or deploy things on the cloud\nplatform, waiting for long build cycles of cloud functions, perform DevOps, etc.\nNo-code friendly but code of every node is accessible and tweakable in javascript/typescript. Comes with features like\ninstant deploy (no need to wait for long build cycles), version control, multiple projects, copying workflows from one\nproject to another, large number of templates on popular usecases - whatsapp bot, google vision, stripe payment, and so\nmuch more.\n‚ú®‚ú® Just Build and Ship, instantly üöÄ\nWhat's inside? üëÄ\nBuilt on top of powerful and scalable Google Cloud Platform (GCP), BuildShip give you a friction-free serverless\ndevelopment experience. Now you can quickly transform your ideas into cloud-deployed scripts within seconds, without\nleaving your browser.\nBuildShip uses Cloud Run to run your code in a serverless environment. It also supports EventArc-based backend\ntriggers, HTTP and webhook backend triggers, data triggers, and BYOC (Bring Your Own Cloud) compatibility.\nFeatures ü™Ñ\n\nCombine the power of any AI Model\nIntegrate the leading multimodal AI models and services with your APIs and Workflows like ChatGPT, Stable\nDiffusion, Midjourney, DALL-E 2, and many more.\nThe Nodeverse\nExplore and select from The Nodeverse, our library of pre-built nodes or generate your own using AI. Tweak the nodes to\nyour liking and build your own custom workflows.\nBuild with JavaScript / TypeScript\nTypical low-code, no-code tools use their own complicated formulae process as you start to building anything meaningful.\nWith BuildShip you can build on javascript / typescript - which has lot of reference materials. So you will not get\n‚Äústuck‚Äù üò∂‚Äçüå´Ô∏è in the tool‚Äôs features and can build without limits.\nOne of a kind development experience\nBuildShip provides you with a powerful code editor with autocomplete, localhost like speedy debugging experience, and a\nsandboxing environment. Build serverless scripts fast, right from your browser! ‚ö°Ô∏è Schedule your function calls, save\ndata to database, connect to any API, use 1M + NPM packages.\nWhy use BuildShip? üö¢\n\nFaster development: BuildShip makes it easy to build and deploy serverless applications, so you can get your\nideas to market faster.\nFlexible and Extensible: BuildShip offers the most flexible and powerful platform to build APIs and backend\nworkflows exactly the way you want. You will never be stuck waiting for an integration.\nLower costs: It's serverless, so you only pay for the resources you use. This can save you a lot of money\non infrastructure costs. You can build 10x workflows for a whole lot less.\nScalability: BuildShip is scalable. So, you can easily scale your applications as your traffic grows!\nGDPR Compliant: You have option to select your project's location and all your workflows will be deployed to that\nregion, which means your data never leaves your region of choice.\nSecurity: Save your API Keys and Secrets on Google Cloud Secret Manager of your own single tenant project, so\nyou can be confident that your data is safe.\nTemplates to start fast: 100s of pre-built integrations, from popular AI models like OpenAI text generation,\nVector embedding, Sythesia video gen, image gen using Stable Diffusion, or literally use any AI model on platforms\nlike Replicate, Hugging Face, etc., or even the ones that will launch in the future!\nAI-Generated Nodes: You are not limited with pre-built nodes or the platform. Start from hundreds of pre-built\nnodes, but if something is missing - don‚Äôt wait for BuildShip to release an integration! Simply ask AI and it\ngenerates a custom workflow node just for you.\nCustom code: Readily use any API or 1M+ NPM packages: You can use any NPM package in the workflow node or ask Ask\nAI to use an NPM package and generate a node for you. Code made accessible - anytime you want: BuildShip is not a\nblack box, you can open the code of any node, tweak it any way you want. Use powerful developer tools like logging,\nversion control, a code editor equipped with autocomplete, a lightning-fast debugger similar to localhost, and a\nsecure sandboxing environment. One-click deploy: When ready, hit ‚Äúship‚Äù and get your backend workflow deployed\ninstantly! Start fast with templates: We have templates featuring chatbots, music generators, reverse image search\nusing Google Vision API, Vector DB search, HTML to PDF converter, and more! They are the team behind Rowy.io - a\npopular low-code tool for managing Firestore data and building low-code style on Firebase and Google Cloud. They have\na great community already building with low-code and the team has been shipping products fast to help and solve\nproducts of the low-code community. The team is part of the first batch of AIGrant.org which has backed top emerging\nAI companies and their investors include Vercel CEO, execs from Figma, Google, Github and more.\n\nBuildShip FAQ\nThe BuildShip FAQ is a collection of useful questions and answers about the project. If you have a question that isn't\nanswered here, please open a discussion.\n\nWhat is a AI generated node?With BuildShip you can use our pre-build nodes or create one yourself by simply asking what you want to the node to\ndo. You can learn more about it here\nWhat is the pricing plan?We are a free tier for you to try out BuildShip and plans to accomodate your needs. You can learn all about pricing\nhere (opens in a new tab).\nüôãüèªNeed help? Chat with us and our community of low-code/no-code builders and developers on\nDiscord (opens in a new tab).Tutorials"
  },
  {
    "title": "Scheduled Interval Trigger ‚Äì BuildShip",
    "url": "https://docs.buildship.com/trigger-nodes/scheduled-interval",
    "html": "Trigger NodesScheduled IntervalScheduled Interval Trigger\n\nThe Scheduled Interval Trigger node is a versatile feature within BuildShip that facilitates workflow automation at\nregular intervals. With this trigger, you can define specific time intervals and units, allowing you to streamline\ntasks and processes based on your requirements.\n\nHow to Use Scheduled Interval Trigger\nConfiguring the Scheduled Interval Trigger involves the following fields:\n\n\nInterval (Unit in digits): Set the numeric value that represents the interval at which your workflow should\ntrigger.\n\n\nTime Unit: Choose the appropriate time unit (e.g., seconds, minutes, hours) for your interval. This unit\ndefines the duration between successive triggers.\n\n\nSetting up the Scheduled Interval Trigger\nTo set up a Scheduled Interval Trigger in your BuildShip workflow, follow these steps:\nAdd Trigger NodeCreate a new workflow or edit an existing one. Click \"Add Trigger\" and select \"Scheduled Interval\" from the available\ntrigger options.Configure TriggerConfigure the fields within the Scheduled Cron Trigger node. You can choose the desired Interval, and time units for\nyour trigger as given in the above sections.\nü¶æUse Cases for Scheduled Interval TriggerExample 1: Every 30 MinutesInterval: 30Time Unit: MinutesDescription: This setup triggers the workflow every 30 minutes, making it ideal for tasks that need to be performed multiple times within an hour.Example 2: Hourly MaintenanceInterval: 1Time Unit: HoursDescription: This configuration triggers the workflow every hour, allowing you to automate routine maintenance tasks.Scheduled CronRowy Trigger"
  },
  {
    "title": "Reordering Nodes ‚Äì BuildShip",
    "url": "https://docs.buildship.com/basics/reordering-nodes",
    "html": "Reordering Nodes\n\nIn BuildShip, you have the flexibility to rearrange the order of your logic nodes within your workflows. This is useful\nwhen you want to change the order of execution of your logic nodes.\nHow to Reorder Nodes\n\nAccess the Workflow Navigation PanelOn the left-hand side of the BuildShip interface, you'll find the Workflow Navigation Panel. This panel displays all the\nnodes in your workflow in their current order.Drag and DropTo rearrange the nodes, simply click and hold on the node you want to move. Drag it to the desired position within the\npanel. As you drag and drop the nodes in the navigation panel, you'll notice that the nodes automatically adjust to\ntheir new order. This mirrors the order you've set in the navigation panel within your workflow.\nüí°Triggers are the starting points of workflows, and thus cannot be reordered. Their sequence remains fixed. Only logic\nnodes can be rearranged as needed.Using VariablesRest API"
  },
  {
    "title": "Welcome to BuildShip ‚Äì BuildShip",
    "url": "https://docs.buildship.com/",
    "html": "Welcome to BuildShip\nA Low-code Visual Backend Builder, powered by AI ‚ú® Use BuildShip to create:\n\nScalable APIs\nScheduled tasks / CRON jobs\nBackend cloud functions\nDatabase CRUD or event data triggered functions\nWhatsApp, Telegram, Slack, Discord, AI chatbot\n\nBuildShip integrates with any tools like Stripe, Sengrid, Whatsapp or AI model from OpenAI, Replicate etc or database\nlike Firebase, Supabase, Postgres.\nü™© Best part? if any integration is missing, don't get stuck - use AI to generate you own workflow nodes. BuildShip\ngives you the best of no-code with the power of low-code. See the 5 minutes product walkthrough.\n\n \n\nQuick Start\n\nFollow the learning resources below to get a deeper understanding of the platform:\nHow to build a workflow?‚ÜíWhat is a node?‚ÜíWhat are workflow triggers?‚Üí\nYou can connect your favorite AI-models, tools, API services, and backend in minutes. Extend your workflow's\ncapabilities with JavaScript / TypeScript code and 1M+ NPM packages! ü§Ø\nBuildShip lets you build scalable backend workflows for the apps you build on any stack. Be it a no-code app builder\n(FlutterFlow, Webflow, Framer, Adalo, Bubble, BravoStudio ...) or a frontend framework (Next.js, React, Vue ...) - you\ncan build scalable backend tasks for them in minutes. This means you don't need to wrangle or deploy things on the cloud\nplatform, waiting for long build cycles of cloud functions, perform DevOps, etc.\nNo-code friendly but code of every node is accessible and tweakable in javascript/typescript. Comes with features like\ninstant deploy (no need to wait for long build cycles), version control, multiple projects, copying workflows from one\nproject to another, large number of templates on popular usecases - whatsapp bot, google vision, stripe payment, and so\nmuch more.\n‚ú®‚ú® Just Build and Ship, instantly üöÄ\nWhat's inside? üëÄ\nBuilt on top of powerful and scalable Google Cloud Platform (GCP), BuildShip give you a friction-free serverless\ndevelopment experience. Now you can quickly transform your ideas into cloud-deployed scripts within seconds, without\nleaving your browser.\nBuildShip uses Cloud Run to run your code in a serverless environment. It also supports EventArc-based backend\ntriggers, HTTP and webhook backend triggers, data triggers, and BYOC (Bring Your Own Cloud) compatibility.\nFeatures ü™Ñ\n\nCombine the power of any AI Model\nIntegrate the leading multimodal AI models and services with your APIs and Workflows like ChatGPT, Stable\nDiffusion, Midjourney, DALL-E 2, and many more.\nThe Nodeverse\nExplore and select from The Nodeverse, our library of pre-built nodes or generate your own using AI. Tweak the nodes to\nyour liking and build your own custom workflows.\nBuild with JavaScript / TypeScript\nTypical low-code, no-code tools use their own complicated formulae process as you start to building anything meaningful.\nWith BuildShip you can build on javascript / typescript - which has lot of reference materials. So you will not get\n‚Äústuck‚Äù üò∂‚Äçüå´Ô∏è in the tool‚Äôs features and can build without limits.\nOne of a kind development experience\nBuildShip provides you with a powerful code editor with autocomplete, localhost like speedy debugging experience, and a\nsandboxing environment. Build serverless scripts fast, right from your browser! ‚ö°Ô∏è Schedule your function calls, save\ndata to database, connect to any API, use 1M + NPM packages.\nWhy use BuildShip? üö¢\n\nFaster development: BuildShip makes it easy to build and deploy serverless applications, so you can get your\nideas to market faster.\nFlexible and Extensible: BuildShip offers the most flexible and powerful platform to build APIs and backend\nworkflows exactly the way you want. You will never be stuck waiting for an integration.\nLower costs: It's serverless, so you only pay for the resources you use. This can save you a lot of money\non infrastructure costs. You can build 10x workflows for a whole lot less.\nScalability: BuildShip is scalable. So, you can easily scale your applications as your traffic grows!\nGDPR Compliant: You have option to select your project's location and all your workflows will be deployed to that\nregion, which means your data never leaves your region of choice.\nSecurity: Save your API Keys and Secrets on Google Cloud Secret Manager of your own single tenant project, so\nyou can be confident that your data is safe.\nTemplates to start fast: 100s of pre-built integrations, from popular AI models like OpenAI text generation,\nVector embedding, Sythesia video gen, image gen using Stable Diffusion, or literally use any AI model on platforms\nlike Replicate, Hugging Face, etc., or even the ones that will launch in the future!\nAI-Generated Nodes: You are not limited with pre-built nodes or the platform. Start from hundreds of pre-built\nnodes, but if something is missing - don‚Äôt wait for BuildShip to release an integration! Simply ask AI and it\ngenerates a custom workflow node just for you.\nCustom code: Readily use any API or 1M+ NPM packages: You can use any NPM package in the workflow node or ask Ask\nAI to use an NPM package and generate a node for you. Code made accessible - anytime you want: BuildShip is not a\nblack box, you can open the code of any node, tweak it any way you want. Use powerful developer tools like logging,\nversion control, a code editor equipped with autocomplete, a lightning-fast debugger similar to localhost, and a\nsecure sandboxing environment. One-click deploy: When ready, hit ‚Äúship‚Äù and get your backend workflow deployed\ninstantly! Start fast with templates: We have templates featuring chatbots, music generators, reverse image search\nusing Google Vision API, Vector DB search, HTML to PDF converter, and more! They are the team behind Rowy.io - a\npopular low-code tool for managing Firestore data and building low-code style on Firebase and Google Cloud. They have\na great community already building with low-code and the team has been shipping products fast to help and solve\nproducts of the low-code community. The team is part of the first batch of AIGrant.org which has backed top emerging\nAI companies and their investors include Vercel CEO, execs from Figma, Google, Github and more.\n\nBuildShip FAQ\nThe BuildShip FAQ is a collection of useful questions and answers about the project. If you have a question that isn't\nanswered here, please open a discussion.\n\nWhat is a AI generated node?With BuildShip you can use our pre-build nodes or create one yourself by simply asking what you want to the node to\ndo. You can learn more about it here\nWhat is the pricing plan?We are a free tier for you to try out BuildShip and plans to accomodate your needs. You can learn all about pricing\nhere (opens in a new tab).\nüôãüèªNeed help? Chat with us and our community of low-code/no-code builders and developers on\nDiscord (opens in a new tab).Tutorials"
  },
  {
    "title": "Loop ‚Äì BuildShip",
    "url": "https://docs.buildship.com/core-nodes/loop",
    "html": "Core NodesLoopLoop\n\nThe Loop node is a versatile tool in BuildShip that empowers you to iterate over elements within a JSON object, an\narray, or even a literal value. This node serves as a powerful mechanism for processing and manipulating data\niteratively. It is particularly useful when you want to perform a series of actions on each element of the input\nprovided.\n\nLooping Functionality\nThe primary functionality of the Loop node is to traverse through all the elements present in the input data and\nperform specified actions on each element. It facilitates the execution of a set of nodes within the loop, allowing\nyou to interact with and modify the data at each iteration.\nThe loop processes each element sequentially. This mode is beneficial when the execution order matters, and actions must\nbe taken step by step. For instance, performing data transformation on each element one after the other.\nUsing the Loop Node\nThe Loop node's functionality revolves around iterating over the elements of the input data and executing a set of\nactions for each element. Here's how you can use the Loop node:\n\n\nInput Configuration: The Loop node accepts three types of input: JSON objects, arrays, or literals.\nYou can provide the input directly in the editor.\n\n\nConcurrency: The Loop node offers the flexibility to set the number of concurrent executions to run. This allows\nyou to control how many iterations are processed simultaneously, enhancing the efficiency of your workflow. (Note: To\nmodify this option, please check the pricing page (opens in a new tab) to see the maximum concurrency\nlimit for your plan.)\n\n\nNode Actions: The Loop node encapsulates a series of nodes within it. This allows you to define the actions\nyou want to perform on each element. You can add nodes for logging, making API calls, calculations, or any other\ndesired functionality.\n\n\nüí°Example: Data TransformationImagine you have an array of raw data that needs to undergo multiple processing steps. You can utilize the Loop node in series mode to accomplish this:Input: JSON array containing raw dataLoop Body: Within the loop, include nodes that perform data transformation, filtering, and enrichment.By using the Loop node in series mode, you ensure that each data point is processed methodically, producing the desired results.\nVideo\nBranch (If Else)Parallel"
  },
  {
    "title": "Scheduled Cron Trigger ‚Äì BuildShip",
    "url": "https://docs.buildship.com/trigger-nodes/scheduled-cron",
    "html": "Trigger NodesScheduled CronScheduled Cron Trigger\n\nThe Scheduled Cron Trigger node is a powerful tool within BuildShip that enables you to automate workflows based on\nscheduled time intervals. This trigger allows you to initiate workflows at specific times, or patterns, ensuring\ntimely execution of your automation tasks.\n\nHow to Use Scheduled Cron Trigger\nThe Scheduled Cron Trigger node comes with three essential fields that you need to configure:\n\n\nLocation: The GCP region where the trigger will be executed. This field is automatically filled based on the\nGCP region associated with your workspace.\n\n\nSchedule: Set the schedule pattern using the cron syntax. This field determines the frequency and timing of\nyour workflow execution. For example, */20 * * * * specifies an interval of 20 minutes.\n\n\nüí°Discover additional information about cron syntax and creating custom cron expressions\nhere.\n\nTime Zone: Choose the desired time zone for your scheduled trigger. You can select from the list of existing\ntime zones.\n\nUnderstanding the Cron Syntax\nCRON syntax is a widely used standard for scheduling tasks in various Unix-like operating systems. It defines a set\nof fields that specify when a task should be executed based on time intervals. Each field represents a unit of time,\nallowing users to define intricate scheduling patterns.\n\nThe CRON syntax consists of five fields, each separated by a space:\n\n\nMinute (0 - 59): Specifies the minute at which the task should run. A value of * indicates any minute, while 0\nindicates the exact minute.\n\n\nHour (0 - 23): Specifies the hour at which the task should run. A value of * indicates any hour, while 0\nindicates midnight.\n\n\nDay of Month (1 - 31): Specifies the day of the month when the task should run. A value of * indicates any day,\nwhile specific numbers represent particular days.\n\n\nMonth (1 - 12): Specifies the month when the task should run. A value of * indicates any month, while specific\nnumbers represent particular months.\n\n\nDay of Week (0 - 6): Specifies the day of the week when the task should run. The values 0 and 7 often represent\nSunday, 1 represents Monday, and so on.\n\n\nThe CRON syntax also supports special characters and shorthand notations:\n\n*/x: Represents every x interval. For example, */15 in the minutes field means every 15 minutes.\nx-y: Represents a range of values. For example, 1-5 in the day of week field means Monday to Friday.\nx,y,z: Represents a list of values. For example, 1,15 in the day of month field means the 1st and 15th day.\n\n‚úÖEXAMPLE 1: Suppose you want to schedule a task to run every day at 3:30 PM.The CRON expression for this scenario would be: 30 15 * * *\nMinute (30): The task should run at the 30th minute of the hour.\nHour (15): The task should run at the 15th hour, which is 3:00 PM in 24-hour format.\nDay of Month (*): The task should run on any day of the month.\nMonth (*): The task should run in any month.\nDay of Week (*): The task should run on any day of the week.\n\n‚úÖEXAMPLE 2: Suppose you want to schedule a task to run every weekday (Monday to Friday) at 9:00 AM.The CRON expression for this scenario would be: 0 9 * * 1-5\nMinute (0): The task should run at the 0th minute of the hour.\nHour (9): The task should run at the 9th hour, which is 9:00 AM.\nDay of Month (*): The task should run on any day of the month.\nMonth (*): The task should run in any month.\nDay of Week (1-5): The task should run on Monday to Friday.\n\nSetting up the Scheduled Cron Trigger\nTo set up a Scheduled Cron Trigger within your BuildShip workflow, follow these steps:\nAdd Trigger NodeCreate a new workflow or open an existing one. Click \"Add Trigger\" and select \"Scheduled Cron\" from the available\ntrigger options.Configure FieldsConfigure the fields within the Scheduled Cron Trigger node. You can choose the desired GCP region, schedule pattern,\nand time zone for your trigger as given in the above sections.\nü¶æUse Cases for Scheduled Interval TriggerExample 1: Daily BackupCRON Expression: 0 0 * * *Description: This expression triggers the workflow every day at midnight. It's perfect for automating daily backups of your data.Example 2: Weekly ReportsCRON Expression: 0 8 * * 1Description: This expression triggers the workflow every Monday at 8:00 AM. It's great for generating weekly reports at the start of the workweek.Rest APIScheduled Interval"
  },
  {
    "title": "API/HTTP Call Node ‚Äì BuildShip",
    "url": "https://docs.buildship.com/core-nodes/api-call-node",
    "html": "Core NodesAPI / HTTP CallAPI/HTTP Call Node\n\nThe API Call is a powerful utility node to HTTP requests to external APIs for data retrieval, submission, or triggering\nactions.\n\nSteps to use API Call Node\nAccessing the Node Editor\nNavigate to the Node Editor where you are building your workflow.\nLocate the 'API Call' node that you want to configure.\nTesting the 'API Call' Node\nHTTP Method: Set the HTTP method for the request. In most cases, you'll choose 'GET' for retrieving data from an\nAPI.\nContent Type: Specify the content type for the request. For JSON data, set it to 'application/json'.\nURL: Enter the URL of the API you want to call.\nReturning the API Call OutputOnce you've configured the 'API Call' node, you can proceed to test it. To do so, follow these steps:\nClick on the 'Test Node' button located in the top-right corner of the Node Editor.\nThe platform will execute the 'API Call' node's logic using the parameters you entered.\n\nIf the execution is successful, a green check-mark will appear on the node.\nüí°In case of an unsuccessful execution, an error message will be displayed. For example, an incorrect URL can lead to\nan error.\nTo view the output of the test run, click on the check-mark. You can copy the output by scrolling to the bottom and\nclicking 'Copy Value'.\n\nLogging During Node Execution\nIf you need to log specific information during the execution of the 'API Call' node, you can include a logging statement\nin the code. This can be helpful for debugging and monitoring the behavior of your workflow.\n\nVideo\n\nThat's it! You've successfully configured and tested an API call using the 'API Call' node in our platform. If you encounter\nany issues or have questions, feel free to reach out to our support team for assistance.ReturnEmpty Script"
  },
  {
    "title": "What is a Trigger? ‚Äì BuildShip",
    "url": "https://docs.buildship.com/basics/trigger",
    "html": "What is a Trigger?\nTriggers are the basis of the execution of any workflow. Each trigger node serves as a starting point for your\nworkflow, allowing you to automate processes based on specific events or schedules. You can only add a single trigger\nnode to a workflow.\n\nWhat are Trigger Nodes?\nTrigger nodes play a pivotal role in BuildShip as they are the catalysts responsible for initiating the execution of\na workflow. Think of them as the \"starting points\" that kickstart the entire automation process.\n\nCharacteristics of a Trigger\n\nTrigger nodes are responsible for triggering the execution of a workflow\nA workflow can have only one trigger node\nTrigger nodes do not have Input / Output manipulation settings\n\nüí°Learn how to structure your HTTP Requests to trigger a workflow here. (Coming soon! üöß)\nTypes of Triggers\nBelow you'll find detailed explaination and examples of our most popular Triggers types:\nRest API Call‚ÜíScheduled Cron‚ÜíScheduled Interval‚ÜíTelegram Bot‚ÜíCreating WorkflowsNodes"
  },
  {
    "title": "Pinecone Integration ‚Äì BuildShip",
    "url": "https://docs.buildship.com/pinecone",
    "html": "PineconePinecone Integration\nThis integration allows you to connect and interact with your Pinecone vector database and perform quick operations such\nas \"Delete Vectors\", \"Upsert Pinecone Index\", \"Query Vectors\".\n\n\nSteps to connect with Pinecone Database\nSetup Pinecone AppCreate an account on Pinecone (opens in a new tab) --> setup application and add organization (follow pinecone\ntour).Create a New IndexCreate an Index to manage vectors and access the required credentials.- Give your index a name. - Add required configurations\nsuch as dimensions and metric - Click createGet Credentials and Variables from created IndexClick on the created index.Get Pinecone API KeyYou will find your Pinecone API key under AI agent API keys (see navigation bar)You are all set to use BuildShip's Pinecone Nodes. üéâ\nExample: Lets upsert some records to Pinecone vector database\nIn this example we will upsert few values of records to the created Pinecone vector index.\n\n\n\nAdd a REST API Trigger and select POST method.\nAdd all the required values from the Vector Index we created above.\nPass the API Key.\nSample Array for record:\n\n[\n  {\n    \"id\": \"1\",\n    \"values\": [0.236, 0.971]\n  }\n]\n\nLets deploy our workflow and test the API on Postman (choose your favorite tool)\n\n\nüéâ Congratulations you have successfully connected and upserted a record in Pinecone Database\nSupabaseTesting"
  },
  {
    "title": "Supabase Integration ‚Äì BuildShip",
    "url": "https://docs.buildship.com/supabase",
    "html": "SupabaseSupabase Integration\nThis integration allows you to work with Supabase database in low-code/no-code style. Using BuildShip, you can connect\nto your Supabase database easily and build APIs, scheduled jobs and any backend workflow automation or cloud functions\non top of your Supabase database - without the need to code.\nYou can use 100s of prebuilt nodes, tempaltes and connectors to popular tools and AI models like Replicate, OpenAI etc.\nAnd if any integration is missing, you can simply ask AI and it will generate one for you right from BuildShip's UI.\nYou can use Supabase with BuildShip in two ways:\nHow to build Supabase Cloud Functions with no code‚ÜíBuilding APIs, CRON / Scheduled Jobs for Supabase visually‚ÜíPerform CRUD operations on Supabase database in your workflows‚Üí\nHow to build Supabase Cloud Functions with no code\n\nTrigged on Supabase data changes i.e. anytime a new row of data is created, updated or deleted\nOr even when new user signs up via Supabase Authentication\nOr at specific times of the day/week/month/year\nFunction is created visually without code\nComes with 100s of prebuilt nodes for your function building including AI models, third party tools\nIf anything is missing your can generate the logic steps of the function with AI and edit code if you would like\n\nPerform CRUD operations\n\nIn your backend workflows, scheduled jobs or APIs\nRead, create (or upsert), update, delete, data in your Supabase database\n\nConnect to any AI model or third party tools\n\nYou can connect your to any AI model on BuildShip to generate content and get it stored on Supabase\nWork with any tools or integrations with ease and with help of AI\n\nüôãüèªNeed help? Chat with us and our community of low-code/no-code builders and developers on\nDiscord (opens in a new tab).WhatsappPinecone"
  },
  {
    "title": "Node Inputs ‚Äì BuildShip",
    "url": "https://docs.buildship.com/basics/input",
    "html": "Node Inputs\n\nInput parameters for a node are variables or values that can be provided as input to the node when it is executed. These\nparameters serve as the data that the node needs to perform its specific task.\nThe input parameters for a node are defined in the node's Inputs section. These parameters can be set in the form\nUI or via JSON schema.\n\nStructure of the Input Configuration\nüí°Open the Inputs section in the code view to see it as a JSON object.\nThe input configuration is a JSON object that defines the input parameters for a node.\n\nLet's understand the structure using an example, here's a sample input configuration for a node:\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"apiKey\": {\n      \"title\": \"API Key\",\n      \"description\": \"The Bearer token for the Cohere API. (Get your Cohere API key [here](https://dashboard.cohere.com/api-keys).)\",\n      \"type\": \"string\",\n      \"pattern\": \"\",\n      \"buildship\": {\n        \"index\": 1,\n        \"sensitive\": true\n      }\n    },\n    \"texts\": {\n      \"title\": \"Texts\",\n      \"description\": \"The array of texts to detect language for. Refer to [Cohere's API Reference Guide here](https://docs.cohere.com/reference/detect-language-1)\",\n      \"type\": \"array\",\n      \"pattern\": \"/^[^A-Z]*$/\",\n      \"buildship\": {\n        \"index\": 0,\n        \"sensitive\": false\n      }\n    }\n  },\n  \"required\": [\"apiKey\", \"texts\"]\n}\nIt has the following structure:\n\n\nproperties: This is an object containing the definition of individual input parameters. In your example, it\ndefines two input parameters: apiKey and texts.\n\n\ntype: This specifies the overall data type of the input. In this case, it is set as \"object,\" indicating that the\ninput parameters are organized within an object structure.\n\n\nrequired: This is an array that can list any required parameters, but it's currently empty, indicating that none\nof the parameters are mandatory.\n\n\nInput Parameter Definition\n\nThe input parameters are defined as follows:\n\ntitle: The user-friendly title or label for the input parameter, which is \"API Key\" in this case.\ndescription: Additional information or description of the parameter, which is \"Cohere API Key.\"\ntype: Specifies the data type of the parameter, which is \"string.\"\npattern: An optional field, typically used for validating the input value. In this example, it's an empty string.\nbuildship: An object that includes additional metadata for the parameter, such as its index within the list of\nparameters and whether it is marked as sensitive (containing sensitive or private data).\nNodesInput Validation"
  },
  {
    "title": "Using Secrets and API Keys ‚Äì BuildShip",
    "url": "https://docs.buildship.com/secrets",
    "html": "Secrets & API KeysUsing Secrets and API Keys\n\nEnsuring the security of your applications and workflows is paramount. Hardcoding sensitive information like secret keys\ndirectly into your code can lead to potential vulnerabilities and increased costs due to unauthorized access.\nBuildShip addresses this concern by providing an effective way to safeguard your secret keys using Google Cloud\nPlatform (GCP) Secret Manager under the hood.\nLeveraging BuildShip Secret Manager\nBuildShip introduces a robust solution to manage your secret keys securely using GCP Secret Manager. This ensures that\nyour keys remain confidential and are only accessed when needed.\nHere's how to use the Secret Keys with BuildShip:\nAdd Secret Key Input Parameter\n\nNavigate to the Node Editor for a logic node where you intend to use a secret key.\n\n\nIn the Params section, add a new input parameter to receive the Secret Key.\n\n\nFor example, let's say you want to use the Replicate API Key. Create an input parameter as follows:\n[\n  {\n    key: 'apiKey',\n    label: 'Replicate API Key',\n    description: 'The API Key for Replicate',\n    required: false,\n    validation: '',\n    type: 'string',\n  },\n];\nor via UI Form:\n \n\n\n\nSave the input parameter.\n\nAccess Secret Key in Node Logic\n\nWithin the Node Editor, navigate to the Node Logic section.\n\n\nImport the input parameters into your function, for example:\nexport default async function runMusicGenModel({ prompt, apiKey }) {\n  // Your code here\n}\n\n\nUse the apiKey variable to access the API Key value in your logic:\nconst replicate = new Replicate({\n  auth: apiKey,\n});\n \n\n\n\nSave your changes.\n\nAdd Secret in BuildShip Secret Manager\nBack to your workflow workspace, click on the Expression Icon </> corresponding to the API Key input in your\nLogic Node.\nUnder \"Secrets,\" click on \"Add a Secret\". This action opens the BuildShip Secret Manager.\n\n\nInside the BuildShip Secret Manager, you have the ability to add, modify, or delete secret keys.\nClick \"Add a Secret Key\", then provide the \"Secret Name\" and \"Secret Value\" associated with your API Key.\n\n\nClick \"Save\" to add the secret key to the BuildShip Secret Manager.\nSelect Secret Key in Node Editor\nBack in the Node Editor, within the Secrets section, click \"Refresh.\"\nSelect the Secret Key you added from the dropdown menu.\n\nAnd that's it! üöÄ By following these steps, you can seamlessly integrate secret keys into your workflows while ensuring\ntheir confidentiality and security through BuildShip's Secret Manager integration.LoggingSupport Messages"
  },
  {
    "title": "Parallel ‚Äì BuildShip",
    "url": "https://docs.buildship.com/core-nodes/parallel",
    "html": "Core NodesParallelParallel\n\nThe Parallel node allows you to run other nodes at the same time. This node is useful if you want to independent pieces\nof logic to run at the same time, saving valueable time in your workflow.\n\nIn parallel mode, each element of the input is processed concurrently. This is suitable when each iteration is\nindependent and can be executed simultaneously. For example, making API calls to multiple endpoints.\nParallel processing executes actions simultaneously for each element, while series processing executes actions one after\nanother.\n‚úÖTo use this node, please check the BuildShip Pricing page (opens in a new tab) to see the maximum\nconcurrency limit for your plan.\nüí°Example: Processing Multiple API CallsSuppose you have a list of URLs that you want to send API requests to simultaneously. You can use the Loop node in parallel mode to achieve this:Input: JSON array containing URLsLoop Body: Inside the loop, add a series of nodes that make API calls to the URLs.This configuration ensures that each API call is executed in parallel, optimizing time and efficiency.\nVideo\nLoopRepeat"
  },
  {
    "title": "Logging ‚Äì BuildShip",
    "url": "https://docs.buildship.com/logging",
    "html": "LoggingLogging\n\nLogging plays a vital role in the development and maintenance of workflows. It allows you to track and understand the\nflow of your workflow, monitor variable values, and identify potential issues.\n\nLogging statements serve as essential tools in your workflow development toolkit. They offer several advantages:\n\nDebugging: Logging helps you identify and resolve issues within your workflow's logic.\nMonitoring: By reviewing log messages, you can monitor the execution flow, identify bottlenecks, and improve\nefficiency.\nData Visualization: Logging enables you to visualize data, making it easier to understand how data changes as the\nworkflow progresses.\n\nYou can harness the power of logging in BuildShip through two primary methods:\nVia Logging Core Node\nThe Logging Core Node provides a straightforward way to log messages and data directly to the BuildShip logging console.\nHere's how:\n\nAdd a NodeClick on the \"Add a Node\" button within your workflow. This will open the Nodeverse Library, where you can explore\nvarious nodes.Find the \"Log Message to Console\" NodeWithin the Core Nodes section, locate the \"Log Message to Console\" node. You can also use the search bar to quickly find\nthis node.Insert and Configure the NodeInsert the \"Log Message to Console\" node into your workflow. Customize the node by adding a string or\nvariable that you want to log.\nVia Logging Statements in Node Logic\nAnother way to integrate logging in your workflow is by directly adding logging statements within the logic of\nindividual nodes. This method gives you more control over when and what to log. Here's how:\n\nSelect and Edit a Logic NodeChoose a Logic Node within your workflow. Open the Node Editor </> to access and edit the node's logic.Import the Logging ModuleInside the parameters of the node, import the logging module. This allows you to use the logging functions.export default async function yourNodeFunction({ input }, { logging }) {\n  // the function body\n  logging.log('This is a logging statement');\n  logging.warn('This is a warning message');\n  logging.error('This is an error message');\n}Within your node's logic, utilize the logging functions to log messages, variables, and other relevant data.\nViewing the Cloud Logs\nAfter incorporating logging statements into your workflow, you can conveniently view these statements using the built-in\nlogging panel in BuildShip.\n\n\nThe logging panel is located at the bottom of your BuildShip Workspace, initially minimized.\nUsers can simply open or close the panel using the expand button on the right to see old logs, if any.\nTo enable live logs while your workflow executes, toggle the \"Live\" switch on. This allows you to monitor logs\nas your workflow progresses via the trigger.\nTo view logs specific to a node or the entire workflow, switch from the default Workflow view to the Node view. To\nview logs for a particular node, select the node from the Node View.\nTestingSecrets & API Keys"
  },
  {
    "title": "What is a Node? ‚Äì BuildShip",
    "url": "https://docs.buildship.com/basics/node",
    "html": "What is a Node?\n\nWithin BuildShip, each node is designated to fulfill a specific function, and the combination of nodes forms a complete\nworkflow.\n\nIt's important to note that the initial node in any workflow must be a trigger node (find more information on triggers\nhere).\n\nThe fundamental building blocks of a workflow are the logic nodes. Let's delve into the details of a logic node's\nstructure and functionality.\nNode Anatomy\n\n\n\nOpen Node Editor </> This feature grants you the power to modify the logic, input parameters, output\nconfiguration, and metadata descriptions associated with a given node, providing the flexibility to tailor the\nnodes to your exact requirements.\n\n\nNode Options Manage nodes through AI-powered editing, deletion, copying, and the ability to view\nlogs specific to each individual node.\n\n\nValue Expression Editor Tap into the capabilities of AI data autofill for inputs, leverage variables, and\nsafeguard sensitive information using secret keys.\n\n\nExpand/Collapse Toggle Enhance your workspace by toggling between expanded and collapsed views for nodes, ensuring\na clutter-free experience.\n\n\nEdit and Customize Nodes\nWhether selecting a node from the Nodeverse library or generating one via AI, the Node Editor provides a\nuser-friendly environment for configuring nodes.\nMoreover, the Node Editor is accompanied by a testing environment, enabling users to edit and test nodes\nsimultaneously, all without the need for deployment.\nNode Editor </>\n\nNode Logic is a versatile code editor within BuildShip that empowers users to create and customize the functionality of\na node. With Node Logic, you can:\n\nWrite and modify the underlying functions for a node to suit your specific needs.\nSeamlessly integrate with APIs, leverage AI models, or incorporate NPM libraries to enhance your workflow's\ncapabilities.\n\nGenerate QR Codesimport { toDataURL } from 'qrcode';\n \nexport default async function generateQRCode({ url }) {\n  const qrCodeDataURL = await toDataURL(url);\n  return qrCodeDataURL;\n}\nüí°If you wish to create your own node from scratch, you can do so by using the Script node.\nInput Params\nInput parameters for a node are variables or values that can be provided as input to the node when it is executed. These\nparameters serve as the data that the node needs to perform its specific task.\nThese parameters can be set in the form UI or via JSON schema.\nüí°Learn more about setting input params via JSON Schema and customizing node input parameters on the Node Inputs\npage.\n\nOutput\nThe Node Editor empowers you to modify your node's output configurations. The structured JSON format ensures clarity in\nhandling resulting data, promoting seamless integration with downstream processes.\nüí°Learn more about setting outputs via JSON Schema and customizing node input parameters on the Node Inputs\npage.\n\nNode Info\nJust as input parameters are accompanied by comprehensive descriptions, the \"Info\" section contains essential insights\nabout the node's purpose and functionality. This contextual information aids in better understanding the node's role\nwithin your workflow.\nüí°Learn more about Node Metadata here.\nTriggersNode Inputs"
  },
  {
    "title": "Tutorials ‚Äì BuildShip",
    "url": "https://docs.buildship.com/tutorials",
    "html": "Tutorials\nStep by step guided tutorial for powerful usecases and examples.\nFirebase‚ÜíFirebase Full Text Search‚ÜíGCP File Storage‚ÜíSupabase‚ÜíPostgres‚Üí\n\nIntroductionCreating Workflows"
  },
  {
    "title": "WhatsApp Integration ‚Äì BuildShip",
    "url": "https://docs.buildship.com/whatsapp",
    "html": "WhatsappWhatsApp Integration\nThis integration provides the most straightforward and efficient means of utilizing the WhatsApp Business Platform Cloud\nAPI to interact with your users and customers. With BuildShip's WhatsApp Node, you can effortlessly construct an entire\nworkflow that enables you to commence customer interactions within a matter of minutes, all without the burden of\nintricate backend configurations.\n\nSending Free-Form Messages through WhatsApp Node\nYou can use this BuildShip's WhatsApp integration node to send the following free-form messages types:\n\nText messages\nMedia messages\n\nRequirements\n\nPermanent user access token is required authorize the user for that app.\nWhatsApp Business Phone Number ID. (from which messages will be sent).\nData (to be sent as object in JSON).\n\nüìù Steps to get required credentials and permissions from Meta - WhatsApp Business Account\nSignup to Meta Developers Dashboard\n\nLogin to Meta Developers Dashboard (opens in a new tab) and go to your app details.\n\n\nSelect My Apps --> Create App\n\n\n\nThen, you‚Äôll need to add products to your app. Scroll down until you see WhatsApp and click the Set up button:\n\n\nSelect Meta Business Account\nFinally, choose an existing Meta Business Account or ask the platform to create a new one and click Continue:\n\n\nVoila, You are all Set! üéâ\n\nAnd with that, your app is created and ready to use. You‚Äôre automatically directed to the app‚Äôs dashboard.\n \n\n\n\nüí°Note that you have a temporary access token. For security reasons, the token expires in less than 24 hours. To get a\npermanent access refer here.\nAlso, When sending a series of messages, the order in which messages are delivered is not guaranteed to match the order\nof your API requests. If you need to ensure the sequence of message delivery, confirm receipt of a delivered status in a\nmessages webhook before sending the next message in your message sequence.\nTime to Test and Ship WhatsApp Node üöÄ\nUse the POST method to call the API and return the whatsapp message object.\nYou can test the node in 'Node Editor'\n \n\nTest the Deployment\n \n\nSteps to get a permanent access token (never expires)\nUnderstanding the necessity of incorporating a bearer token within the Authorization header of an HTTP request is\ninformative, yet it's only the tip of the iceberg. The access tokens you've encountered thus far are essentially\nephemeral. It's likely that you aim to enable your application to interact with the API beyond a mere 24-hour timeframe,\nwhich necessitates the creation of a more enduring access token.\nAll you need to do is add a System User to your business account to obtain an access token you can use to continue\naccessing the API.\nTo create a system user, do the following:\n\nGo to Business Settings\nhere (opens in a new tab).\nSelect the business account your app is associated with.\nBelow Users, click System Users.\nClick Add.\nName the system user, choose Admin as the user role, and click Create System User.\nSelect the whatsapp_business_messaging permission.\nClick Generate New Token.\nCopy and save your token.\n\nYour access token is a random string of letters and numbers.Utility NodesSupabase"
  },
  {
    "title": "Support Messages ‚Äì BuildShip",
    "url": "https://docs.buildship.com/support-messages",
    "html": "Support MessagesSupport Messages\n\nIf you ever get stuck or need help with anything BuildShip, you can reach out to us using Support Messages.\nTo submit a support message, click on the 'Support' button in the bottom-left corner of the screen. This will open up a\nform where you can submit your message (including screenshots and video links if you wish to include any).\n\nIncluding a copy of the workflow\nIf you're having trouble with a specific workflow, you can include a copy of it in your support message (using the\ncheckbox at the bottom of the form) for us to take a look. For the checkbox to appear, you must have the workflow open\nin the editor before opening the support form.\nMarking inputs as sensitive\nTo ensure no sensitive data (like an API key) is included in the workflow, any input fields marked 'Sensitive' will be\nredacted from the copy of the workflow that is sent to us. You can mark a field as sensitive by following these steps:\nOpen the Node Editor for the node whose input(s) you wish to mark as sensitive.Switch to the 'Params' tab of the Node Editor and select the input you wish to mark as sensitive.Enable the 'Sensitive' toggle for that input if it isn't already enabled.Click 'Save' to save your changes.Secrets & API Keys"
  },
  {
    "title": "Rowy Trigger ‚Äì BuildShip",
    "url": "https://docs.buildship.com/trigger-nodes/rowy-trigger",
    "html": "Trigger NodesRowy TriggerRowy Trigger\n\nRowy Triggers in BuildShip allow you to initiate a BuildShip workflow in response to specific events within your Rowy\nProject. This integration enables you to automate tasks seamlessly based on events that occur in your Rowy environment.\nüöÄThis method also acts as a Firebase Trigger, allowing you to efficiently manage your Firebase Data with both Rowy\nand BuildShip.\n\nPre-requisites ‚úÖ\nFor this integration to work, you will need:\n\nA Rowy Project with a Rowy Run set up. If you don't have a Rowy Project, you can create one here (opens in a new tab).\n\nConfiguration in BuildShip\nAdd a Rowy TriggerAfter creating a new workflow in BuildShip, click on Add a Trigger and select Rowy Trigger from the available options.Add in your Rowy Project IDIn the Project ID field add your Rowy Project ID. Click on the link icon on the top right within the trigger to copy the\nconfiguration details required for the next steps.üëÄTo get your Rowy Project ID, go to your Rowy Table and click on your profile picture on the top right. You'll find the Project ID under the your Email Id.\nThis is all you need to do in BuildShip to set up the Rowy Trigger. Now, let's set up the BuildShip Extension our Rowy\nTable.\nSetting up the Rowy Extension\nAdd the BuildShip ExtensionIn your Rowy Table, access the extensions menu and add a \"BuildShip Trigger Extension\".Select Trigger EventsChoose the specific events within Rowy that will trigger the BuildShip extension. You can select from events:\nCreate\nUpdate\nDelete\nSpecify Required Fields (Optional)Optionally, you can define the required fields that must be populated to trigger the extension.Set Trigger Conditions (Optional)If needed, add conditions that determine whether the extension should be triggered for a given row.Configure BuildShip TriggerWithin the extension body, navigate to the return statement. You'll find the \"buildshipConfig\" object, which includes\nthe following fields:buildshipConfig: {\n      projectId: \"\",\n      workflowId: \"\"\n}Replace the placeholder with the configuration details copied from your BuildShip Rowy Trigger. It should look something\nlike this:buildshipConfig: {\n  projectId: \"buildship-008vd0\",\n  workflowId: \"zE49cCs5kBmg7GkUwzLt\"\n}Save and DeployOnce you've configured the extension to your requirements, click on \"Add\" and then deploy the extension.\nNow, whenever the selected event (Create, Update, or Delete) occurs in your Rowy Table, it will trigger the BuildShip\nworkflow linked to this extension.\n\nüôãüèªIn case you of any issues or need further help, chat with us on Discord (opens in a new tab).Scheduled IntervalTelegram Bot"
  },
  {
    "title": "Branch (If Else) ‚Äì BuildShip",
    "url": "https://docs.buildship.com/core-nodes/if-else",
    "html": "Core NodesBranch (If Else)Branch (If Else)\nThe Branch node is a conditional node in your workflow, designed to execute different sets of actions based on a\nspecific condition. This node provides a powerful way to control the flow of your workflow, making it flexible and\ndynamic.\n\nUsing the Branch node\nThe Branch node evaluates a base condition. If the condition evaluates to \"true\", the node executes the actions\nin the \"Then\" block. If the condition evaluates to \"false\", it proceeds to execute the actions in the \"Else\"\nblock.\nSupported Comparison Operators\nTo define your conditions, the \"Branch\" node supports the following comparison operators:\n\n==: Checks whether two values are equal\n!=: Checks whether two values are not equal.\n>: Checks whether the first value is greater than the second value.\n<: Checks whether the first value is less than the second value.\n>=: Checks whether the first value is greater than or equal to the second value.\n<=: Checks whether the first value is less than or equal to the second value.\n\nüí°These comparison operators also work on strings. You can use them to compare string values and make decisions\nbased on string conditions.\nWith these operators, you can construct various conditions to control the flow of your workflow based on specific data\nor inputs.\nExample: Conditional Response Based on Request Body\nIn this example, we'll create a workflow that receives an HTTP request with a JSON body. The workflow will check the\nvalue of the number key in the request body. If the value is greater than 10, the workflow will return a message\nsaying that the number is greater than 10. If the value is less than or equal to 10, the workflow will return a message\nsaying that the number is less than or equal to 10.\n\nHTTP Trigger NodeCreate a workflow with an HTTP Request Trigger to receive incoming requests.Add Branch NodeAdd a Branch (If Else) node to the workflow.Set Branch ConditionClick on the Expression Menu, select Expression Editor. Set the Branch node's condition as:ctx[\"request\"][\"body\"][\"number\"] > 10Setting Then and Else conditions\nIn the \"Then\" block of the Branch node, add a Return node with the message:\nctx[\"request\"][\"body\"][\"number\"] + \" is greater than 10\".\nIn the \"Else\" block of the Branch node, add another Return node with the message:\nctx[\"request\"][\"body\"][\"number\"] + \" is less than 10\".Test the WorkflowClick deploy and send a request to the given endpoint with a JSON body containing the number key. Here's an example body JSON:{\n    \"number\": 15\n}\nExecution of the Example\n\n\nIf the incoming requests' number key has a value greater than 10 (e.g., \"number\": 15), the workflow returns\n15 is greater than 10.\n\n\nIf the incoming requests' number key has a value less than or equal to 10 (e.g., \"number\": 5), the workflow\nreturns 5 is less than or equal to 10.\n\n\nNested Branch (Nested If Else)\nA Nested Branch or a Nested If Else is a conditional structure within another conditional structure. Using\nnested branches allows you to create more complex conditional logic in your workflow by combining multiple levels of\n\"if-else\" statements. This approach is useful when you need to evaluate multiple conditions sequentially, with each\ncondition leading to a different set of actions.\nNested Branch Example\nLet's consider a scenario where we want to categorize incoming numbers into three groups: \"Greater than 20,\" \"Between 10\nand 20,\" and \"Less than or equal to 10.\"\n\nHTTP Trigger NodeCreate a workflow with an HTTP Request Trigger to receive incoming requests.Add Branch NodeAdd a Branch (If Else) node to the workflow.Set Branch ConditionClick on the Expression Menu, select Expression Editor. Set the Branch node's condition as:ctx[\"request\"][\"body\"][\"number\"] < 20Adding Nested conditions\nIn the \"Then\" block of the first Branch node, add another Branch (If Else) node.\nSet the condition in the second Branch node as\nctx[\"request\"][\"body\"][\"number\"] > 10\nIn the \"Then\" block of the second Branch node, add a Return node with the expression:\nctx[\"request\"][\"body\"][\"number\"] + \" is between 10 and 20\"\nIn the \"Else\" block of the second Branch node, add another Return node with the message:\nctx[\"request\"][\"body\"][\"number\"] + \" is less than or equal to 10\"\nIn the \"Else\" block of the first Branch node (i.e., if the number is not greater than 20), add a Return node with the message:\nctx[\"request\"][\"body\"][\"number\"] + \" is greater than 20\"Test the WorkflowClick deploy and send a request to the given endpoint with a JSON body containing the number key. Here's an example body JSON:{\n    \"number\": 15\n}Telegram BotLoop"
  },
  {
    "title": "Node Input Validation ‚Äì BuildShip",
    "url": "https://docs.buildship.com/basics/input-validation",
    "html": "Node Input Validation\n\nIn BuildShip, you have the ability to specify a regular expression pattern for input fields. This allows you to define a\npattern that a value must match to be considered valid.\nIf the value provided in the input does not match the specified pattern, the workflow will generate a node validation\nerror, preventing the execution of the workflow.\n\nHow to Specify Validation Regex\nTo configure Validation Regex for an input field, follow these steps:\nOpen the Node EditorOnce you have a node for which you wish to validate the inputs, open the node editor by clicking on the </> icon in the top right corner of the node.Open the Input EditorNavigate to the \"Inputs\" tab within the Node Editor and select the input field/s you wish to validate.Specify the Validation RegexYou'll spot the \"Validation Regex\" at the bottom of the input editor. Enter the regular expression pattern you wish\nto use to validate the input field.Test the Validation RegexOnce this is done, click the \"Save\" button to save your changes. You can test your validation regex by entering a value\nthat does not match the pattern you specified. If the value does not match the pattern, you'll see a validation error\nappear below the input field when you click on the \"Ship\" button.\nExample Validation Regex\nLet's consider an example using the regular expression pattern ^[A-Za-z0-9]+$. This specific pattern is designed to\nmatch a string that consists of one or more alphanumeric characters, which includes letters (both uppercase and\nlowercase) and digits.\nHere's how the process works:\nInput Field ConfigurationIn the Node Editor, you pick the input field you want to validate, and you add the regular expression pattern in the Validation Regex field for that input.Pattern MatchingWhen the workflow is executed, the Validation Regex function checks if the value provided in the input field matches the\nregular expression pattern defined in the Validation Regex field.Validation Results\n\nCASE 1: If the input is abc123, it matches the pattern (consisting of alphanumeric characters only), and\ntherefore, no validation error is generated. The workflow proceeds as expected.\n\n\n\nCASE 2: If the input is abc-123,it contains a hyphen, which does not match the specified pattern. In this case,\nthe workflow will generate a validation error before proceeding, preventing the building of the workflow.\n\nNode InputsNode Output"
  },
  {
    "title": "REST API Call Trigger ‚Äì BuildShip",
    "url": "https://docs.buildship.com/trigger-nodes/rest-api",
    "html": "Trigger NodesRest APIREST API Call Trigger\nWith this powerful trigger node, you can initiate automation by sending HTTP requests to specified URL endpoints.\nWhen setting up the REST API Call Trigger, you define the path, choose the HTTP method (GET, PUT, POST, DELETE),\nand create the complete endpoint URL.\n\nSetting up a REST API Call Trigger in BuildShip\nTo set up a REST API Call Trigger in your BuildShip workflow, follow these steps:\nAdd Trigger NodeIn a fresh workflow, click \"Add Trigger,\" and select \"Rest API Call\" from the available options. The Rest API Call trigger comes with three fields:\nPath: Specify the URL Endpoint to which you want to send the request.\nMethod: Choose the appropriate HTTP method for your request, such as GET, PUT, POST, or DELETE.\nEndpoint URL: This is the complete request URL, including the endpoint you specified in the Path field.\nPlatform to send RequestsThe REST API Call Trigger allows you to pick any platform to trigger an HTTP request to the specified Endpoint URL. This\nflexibility empowers you to integrate BuildShip with various applications and services seamlessly.\nExample: Triggering a Workflow with a REST API Call\nCalculator - Multiplying two numbers and returning the result\nNODE 1: Trigger - Rest API Call\nSet path to /calculator\nMethod: POST\nCopy the endpoint URL\nNODE 2: Calculator Node\nSelected a pre-built Calculator Node from the Node Library.\nTo add first and second numbers, click on the Expression (x) icon ‚Üí Select Expression ‚Üí Click on the\nExpression Editor ‚Üí Click on Insert Variable ‚Üí Under Request, select Body and add the key in either of\nthe following formats: [\"num1\"] or .num1.\nRepeat the above step for the second number.\nSelected the operation as MULTIPLY.\nNODE 3: Return Node\nAdded a pre-built Return Node from the Node Library.\nSet the Status Code to (OK) 200\nFor the Value, click on the Expression (x) icon ‚Üí Select Expression ‚Üí Click on the Expression Editor ‚Üí Click on\nInsert Variable ‚Üí Under Calculator, select Result.\nTesting the WorkflowTo test our our Workflow, let‚Äôs go to Postman. Add in the copied Endpoint URL and set the request method to POST. (Same\nas we had set up in the Trigger Node)Add in the body and click Send! üöÄReordering NodesScheduled Cron"
  },
  {
    "title": "What is a Workflow? ‚Äì BuildShip",
    "url": "https://docs.buildship.com/basics/workflow",
    "html": "What is a Workflow?\n\nA workflow is a visual representation of a logical sequence of tasks designed to achieve a specific goal. Each task\nis represented by a node, and workflows are constructed to automate processes, streamline tasks, and efficiently respond\nto various events.\nKey characteristics of workflows include:\n\nTrigger Nodes: The first node is a trigger that initiates the workflow\nNodes: Each node represents a specific task or action within the workflow\nReturn Nodes: The last node can be a return statement, providing optional final outputs\n\nHow to build a Workflow?\nHere's a comprehensive guide to building a workflow using BuildShip:\nCreate a new workflowBegin by initiating a new workflow on the BuildShip dashboard.Navigate to the BuildShip dashboard and click on the \"New Workflow\" button.üí°Alternatively, you can select a suitable template from the available options.Adding TriggersTriggers initiate workflows based on specific events.Click on the \"Add a Trigger\" button within your newly created workflow. Select from the list of existing triggers,\nsuch as HTTP Requests, Scheduled Intervals, or Cron Jobs.Adding Logic NodesLogic nodes perform tasks and actions within your workflow.Explore the Nodeverse, which offers a variety of pre-built nodes for data processing, communication, and more. Select\nnodes that align with the tasks you want to accomplish.You could also create your own custom nodes using the \"Generate with AI\" feature from the Nodeverse.Configuring the NodesWith BuildShip's low-code capabilities, configuring each node is a user-friendly process that empowers you to tailor\nyour workflow to your exact requirements. Here's how you can do it:\nClick on the Script Icon on the node to open the Node Editor.\nPersonalize the node's behavior according to your specific needs by manipulating the Node Logic, Input Params, Output,\nas well as the Node Description.\nReturning data from the WorkflowOptionally, include a return statement at the end of your workflow.The return statement provides output values that can be used for further processing or as a response.\nCongratulations! You've successfully created a dynamic workflow tailored to your needs. üöÄTutorialsTriggers"
  },
  {
    "title": "Testing ‚Äì BuildShip",
    "url": "https://docs.buildship.com/testing",
    "html": "TestingTesting\n\nThe Testing feature in BuildShip's Node Editor empowers users to rigorously test their node logic without the need to\ndeploy the entire workflow. This functionality offers a dedicated space to validate your node's behavior, ensuring\nthat it handles various scenarios, including edge cases, effectively.\nTesting Individual Nodes\nDuring the development of your workflows, you have the ability to test individual nodes right from the Node Editor.\nThis streamlined approach allows you to validate the functionality of your nodes without the necessity of deploying the\nentire workflow.\nHere's how you can test individual nodes:\nCreate or Select a NodeBegin by creating a custom node using our AI Node Generator or selecting a node from the Nodeverse that aligns\nwith your workflow requirements.Open the Node EditorAccess the Node Editor </> to view and modify the configuration of your chosen node. You can even customize nodes\nusing JavaScript or TypeScript to meet your specific needs. (For more information on editing nodes, refer to our\nguide on node customization.)Testing NodesOn the left side of the Node Editor, you'll find the Testing Node. This feature allows you to manually input\nvalues that correspond to the inputs of the node you're testing. This way, you can ensure that your node's logic\neffectively covers various edge-case scenarios.Test Node LogicOnce you've input the test values, click the \"Test Node\" button. This action evaluates your node's logic against the\nprovided test case without requiring you to save or deploy the entire workflow. In case of any errors, you'll receive a\ndetailed error message, once you click on the exclamation mark, that you can use to debug your node's logic.\nTesting Entire Workflows\nBeyond testing individual nodes, BuildShip enables you to validate the functionality of your entire workflow,\nincluding triggers and logic nodes, before deploying it.\n\nFollow the steps below to test your workflow:\nBuild Your WorkflowCreate your workflow by adding triggers and logic nodes that define the sequence of actions to\nachieve your goals. (Or pick up a pre-built template or a set of pre-built nodes via the Nodeverse)Access the Testing ModeAt any point in your workflow-building process, click on the \"Test\" button located in the top-right menu.Configure ParametersBefore running the test, provide any necessary parameters. For instance, in the case of an HTTP Trigger, you can specify\nthe request body that your trigger will receive.Run the TestClick \"Run\" to initiate the test. Your logic nodes will execute one after another, validating their functionality.\nSuccessfully executed nodes will display a green checkmark ‚úÖ, while any failing nodes will be marked with a red\nexclamation mark ‚ùóÔ∏è.DebuggingIn case of node failures, the testing mode reveals the exact node responsible for the error occured. Clicking on the\nexclamation mark reveals the error code and message, helping you pinpoint and address issues efficiently.\nWith BuildShip's testing capabilities, you can iterate through your workflow design, ensuring its effectiveness and\nidentifying any flaws or bugs before deploying it to your production environment.PineconeLogging"
  },
  {
    "title": "Telegram Bot Trigger ‚Äì BuildShip",
    "url": "https://docs.buildship.com/trigger-nodes/telegram-bot",
    "html": "Trigger NodesTelegram BotTelegram Bot Trigger\n\nThe Telegram Bot is a handy trigger within BuildShip that enables you to **handle incoming messages in Telegram chat\nor Telegram group with a visual workflow builder.\nThis trigger allows you to easily manage Telegram groups, moderate and respond with meaningful messages and even include\nOpenAI in your workflow to generate meaningful responses to assist users in your group.\n\nPre-requisites ‚úÖ\n\nTelegram bot API key - The API keys of the Telegram bot that will be responding to the incoming messages. To\nsetup a bot and get the API key, follow the instructions here.\nTelegram group Chat ID - This is the group on which your Telegram bot will operate and listen to messages and\nsend responses to. To learn how setup a group and get chat id, go\nhere.\n\nStep to create a Telegram Bot workflow\nAdd the Telegram Bot TriggerAdd the telegram bot's API Key, that you can get from this step.  Also,\noptionally you can add a Verification Code if you want incoming requests to be verified.  Add \"Send Telegram message\" Node\nNext to you workflow, add a node by searching in the node explorer for \"Send Telegram message\" node to reply to\nincoming messages.\nAdd the \"Chat ID\" of the group that you want the bot to reply to.\nTo this node also add the response \"Text\" that you want the bot to reply with. We have added here, a generic message\nof \"Welcome to the group...\".\nYou can however, add nodes like OpenAI text generation to respond with AI, or even verify if the incoming message is\nfrom a Stripe paying user before responding\nThere is full flexibiliy to add more nodes and handle what your bot is replying with. \n\n\nReturn success status and click ShipFinally, add a \"Return\" node that will respond with a success status. And click the \"Ship\" button to deploy the workflowSend a message to TestFinally, you can send a message and test the response is as expected.That's it üéâThis is a starting point, you can tweak this anyway you like.\nHow to setup a Telegram bot and get API key\n\nEnter @BotFather in the search tab and select the verified bot with tick mark that shows up. \n\n\nClick Start to activate the BotFather bot. You will receive a list of commands to manage the bots.\nChoose or type the /newbot command and click Send.\nChoose a name for your bot. Your subscribers will see it in their conversations. Next, choose a username for your\nbot. The bot can be found by its username in the search bar. The username must be unique and end with the word ‚Äúbot.‚Äù\nOnce you've made your selection for your bot's name, your bot will be brought to life. Shortly thereafter, you'll\nreceive a message containing a link leading to your bot, which can be accessed at \"t.me/[bot_username] as well as\nyour API key.\nMake note of this API key as this is what you will need to use in the Telegram Trigger node on BuildShip. \n\n\n\nHow to setup a Telegram group and get chat id\n\nCreate a group on Telegram\nInvite the bot you created in the previous steps\nAlso search and invite \"RawDataBot\" to your group.  \nOnce you invite this RawDataBot to your group, it will post a message with the Chat ID of this group. Make a note of\nit for use in the Step 2 of your Telegram workflow.\n\n\n\n\n\n\nüôãüèªNeed help? Chat with us and our community of low-code/no-code builders and developers on\nDiscord (opens in a new tab).Rowy TriggerBranch (If Else)"
  },
  {
    "title": "Return Node ‚Äì BuildShip",
    "url": "https://docs.buildship.com/core-nodes/return",
    "html": "Core NodesReturnReturn Node\nThe Return Node is used to return values from the workflow. It is the last node in the workflow and is always\nrequired. The Return Node is a crucial component in our workflow logic, designed to handle HTTP response codes and\nreturn a value upon execution.\nThe Return Node is a non-configurable node that takes in predefined HTTP status codes and produces a corresponding\nvalue as output.\n\nSupported Status Codes\nThe Return Node supports the following HTTP status codes:\n\n200: OK\n201: Created\n202: Accepted\n204: No Content\n400: Bad Request\n401: Unauthorized\n403: Forbidden\n404: Not Found\n500: Internal Server Error\n\nReturn Value\nThe Return Nodes in the workflow allow users to generate specific output values based on various sources, providing\nflexibility and customization to the workflow logic. The Return Node can be used to return a value from the following\nsources:\nAutofill Values using AI\nThe Return Nodes can leverage the power of AI to autofill values automatically. By using AI-driven autofill feature,\nusers can save time and ensure that the generated values align with the workflow's objectives.\nValues via Expressions\nReturn Nodes support expressions, allowing users to create dynamic output values by combining variables, constants, and\nfunctions. Expressions enable users to manipulate data and perform calculations, making it possible to generate\nresponses that adapt to changing conditions during workflow execution.\nRequest Components\nIn workflows involving REST API triggers, Return Nodes can return values derived from different components of the\nrequest. Users can extract data from the request's headers, parameters, and body to generate meaningful responses.\nFor Example: The Return Node can extract the user's name from the request header and use it to personalize the\noutput message.\nReturning Output Values from Previous Nodes\nThe power of workflows lies in their ability to connect and pass data between nodes. Return Nodes can utilize output\nvalues from previous nodes in the workflow. By referencing the outputs of other nodes, users can build complex logic and\ncreate cascading effects.\nFor Example: If a previous node performs a calculation or retrieves data from a database, the Return Node can use\nthat data to provide the final result of the workflow.\nVideo\nRepeatAPI / HTTP Call"
  },
  {
    "title": "Node Output ‚Äì BuildShip",
    "url": "https://docs.buildship.com/basics/output",
    "html": "Node Output\n\nOutput configuration for a node involves specifying how the node will produce and format its output data. It defines the\nstructure and content of the data that the node will generate as a result of its execution.\nThe output configuration is defined in the output section of the node configuration file. These parameters can be\nset in the form UI or via JSON schema.\n\nStructure of the Output Configuration\nThe structure is a JSON object that defines the output configuration for a node.\nLet's understand the structure using an example, here's a sample output configuration for a node:\n{\n  \"buildship\": {},\n  \"description\": \"The response from the Cohere detectLanguage API\",\n  \"type\": \"object\",\n  \"title\": \"Cohere Response\",\n  \"properties\": {}\n}\n\n\ndescription: This field provides a brief description of the output. In this case, it describes the output as \"The\nresponse from the Cohere detectLanguage API.\"\n\n\ntype: Specifies the overarching data type of the output, which is \"object.\" This indicates that the output data will\nbe structured as a JSON object.\n\n\ntitle: This is a user-friendly title or label for the output, which is \"Cohere Response\" in this example.\n\n\nproperties: This field is typically used to define the individual components or variables within the output data.\nHowever, in this example, it's empty, which means that there are no specific properties defined for the output.\n\nInput ValidationUsing Variables"
  },
  {
    "title": "AI Generated Nodes ‚Äì BuildShip",
    "url": "https://docs.buildship.com/ai-nodes",
    "html": "Generate with AIAI Generated Nodes\n\nThere are two ways to build custom nodes in BuildShip:\n\nPicking pre-built nodes via the Nodeverse\nBuilding custom nodes via AI\n\nBuilding Custom Node via AI\nIn BuildShip, you have the flexibility to create custom nodes for your specific use cases using an integrated AI-powered\nnode building feature. This process allows you to streamline the node creation process through intelligent prompts.\nLet's explore how to build custom nodes using this AI feature:\nOpen the AI Node GeneratorClick on the wand icon ü™Ñ on the top left menu bar to open the AI Node Generator. This action will open the AI Node\nGenerator, where you'll be able to initiate the node creation process.Give the prompt to generate the nodeThe AI Node Generator modal asks you to give a prompt for the node you want to generate. This prompt serves as a\nguideline for the AI to understand your requirements.Check out the following image for an example prompt. Once you have given the prompt, click on the \"Generate\" button\nto generate the node.üí°Users can also specify the exact format they want the output of the node to be generated in. For example, if you want the output to be in the form of a JSON object, you can specify that in the prompt.The resultant output should be in the form of a JSON object with the following format:\n{\n    \"cover\":{\n        \"title\":string,\n        \"subtitle\":string,\n        \"illustration\":string\n    },\n    \"pages\":[\n        {\n            \"index\":number,\n            \"illustration\":string,\n            \"text\":string\n        }\n    ]\n}Explore and Modify the Node via the Node ExplorerOnce the AI generates the node based on your prompt, you can explore its functionalities and make further modifications\nusing \"Node Explorer </>\". This is a powerful tool that allows you to fine-tune the node's logic, input\nparameters, output configurations, and metadata descriptions. For more details on customizing nodes, refer to\nthe editing nodes section.Testing the NodeThe Node Editor provides a convenient testing feature, allowing you to test the newly created node using sample data\nwithout deploying the entire workflow. This ensures that the node operates as expected before full implementation. To\nlearn more about testing nodes, refer to the testing nodes section.\nBy following these steps, you can efficiently create custom nodes tailored to your specific automation requirements! üöÄ\nAI Autofill Input\nBuildShip offers an AI Autofill feature that allows users to automatically populate node inputs with static or dynamic\ndata. Here's how you can effectively leverage AI Autofill to automate the node data:\nOpen the Expression Editor (x)While configuring a node, locate the expression icon (x) and click on it to open the Expression Editor.Select and Define a PromptWithin the expression editor, you'll notice an Autofill icon. Click on this icon to enable the add your prompt.Provide a precise and descriptive prompt that articulates the specific data you need. The clarity of this prompt is\ncrucial for the AI to generate accurate values.For instance, you might define a prompt like:I need to autofill the value to the current unix timestamp\nAll you need to do now is to check if the generated value matches your requirements. You can modify the prompt as many\ntimes as you like and request a different value to fit your use case.Empty ScriptUtility Nodes"
  },
  {
    "title": "Utility Nodes ‚Äì BuildShip",
    "url": "https://docs.buildship.com/utility-nodes",
    "html": "Utility NodesUtility Nodes\n\nUtility Nodes are a diverse collection of pre-built nodes created to simplify a wide range of tasks and utilities\nwithin your BuildShip workflows.\n\nThese nodes can be found in the Node Explorer under the Utilities section.\nUtility nodes can serve as building blocks for your workflows, allowing you to automate tasks whether you're\ndealing with data manipulation, web interactions, calculations, or other common tasks.\nHow to Use Utility Nodes\nTo use a Utility Node, simply go to the Node Explorer and select any node from the utility section into your\nworkflow.\nUtility nodes are pre-built so, you don't need to write any code. Utility nodes are also fully customizable,\nso you can tailor them to your specific needs either via the AI node modifier or by writing your own logic.\nCustomization\nBuildShip empowers you to fully customize Utility Nodes to align them precisely with your unique workflow requirements.\nHere's how you can tailor these nodes:\n\nNode Editor (</>): Enter the Node Editor to modify the Node Script using JavaScript (JS) or TypeScript (TS).\nCustomize input and output parameters, as well as the node description to suit your specific use case.\n\n\nüí°Learn more about how to customize nodes here.\n\nAI Node Modifier: Customize nodes effortlessly without coding. Click the Magic Wand icon (ü™Ñ) to open an AI\nprompt modal. Type your instructions or modifications for the node, and the AI Node Modifier will automatically apply\nthem.\n\n\nWith this level of customization, you can adapt Utility Nodes to perform exactly the utilities you need within your\nworkflows, ensuring maximum efficiency.\nAvailable Utility Nodes\nBuildShip offers a growing library of Utility Nodes to cater to your automation needs. Below are some examples of\nthese nodes:\n\n\nAPI Call: Make HTTP requests to external APIs for data retrieval, submission, or triggering actions. Learn more in\ndetail here\n\n\nCalculator: Perform mathematical calculations and operations on numeric values.\n\n\nCombine Vector Embeddings: Merge vector embeddings or feature vectors for machine learning and data analysis.\n\n\nForm Value Extractor: Extract values from structured data sources, such as web forms or JSON payloads.\n\n\nGenerate PDF from HTML: Convert HTML content into PDF documents for reporting and documentation.\n\n\nGenerate QR Code: Create QR codes containing information or data for various applications.\n\n\nText to Lowercase: Convert text or strings to lowercase for consistent text processing.\n\n\nNeighbor Search: Perform searches based on proximity or similarity.\n\n\nPDF to Text: Extract text content from PDF documents for further processing.\n\n\nRedirect Request: Redirect HTTP requests to other URLs or endpoints.\n\n\nScrape Web URL: Extract data from web pages by scraping their content.\n\n\nWe're continually expanding the range of Utility Nodes to meet evolving automation needs.Generate with AIWhatsapp"
  },
  {
    "title": "Repeat ‚Äì BuildShip",
    "url": "https://docs.buildship.com/core-nodes/repeat",
    "html": "Core NodesRepeatRepeat\n\nRepeat node is similar to loop node however you can repeat/loop over other nodes x number of times. You can mention how\nmany times you want to repeat a task and add all the logic nodes inside the repeat node.\n\nVideo\nParallelReturn"
  },
  {
    "title": "Script Node ‚Äì BuildShip",
    "url": "https://docs.buildship.com/core-nodes/script",
    "html": "Core NodesEmpty ScriptScript Node\n\nA Script Node is a flexible building block in your workflow automation system. It provides a blank canvas for you to\nwrite your custom logic.\nUsers can configure input parameters, specify the output format, and add metadata to describe the node's\npurpose and appearance.\n\nCustomzing the Script Node\nNode Logic\nThe core of a Script Node is its logic, where you define the custom behavior of the node. This logic is typically\nwritten in JavaScript/TypeScript.\n\nBelow is an example of a Script Logic for generating QR codes:\nimport { toDataURL } from 'qrcode';\n \nexport default async function generateQRCode({ url }) {\n  const qrCodeDataURL = await toDataURL(url);\n  return qrCodeDataURL;\n}\nIn the above example, we import the toDataURL function from the\nqrcode NPM Library (opens in a new tab) and create an asynchronous function generateQRCode. It\ntakes an input parameter url, generates a QR code image, and returns its data URL.\nInput Parameters\nInput parameters are values that users can configure when using the Node. These parameters can be set in the form UI or\nvia JSON schema.\n\nHere's the input configuration (in JSON) for the QR code generation node:\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"url\": {\n      \"buildship\": {\n        \"index\": 0\n      },\n      \"description\": \"The URL to generate a QR code for\",\n      \"title\": \"URL\",\n      \"type\": \"string\"\n    }\n  },\n  \"required\": [\"url\"]\n}\nHere,\n\ntype: Specifies that the input is an object.\nproperties: Defines the available input properties. In this case, we have a single property, \"url.\"\nurl: Describes the \"url\" property. It has a title, description, and data type (string). The \"buildship\" section\nincludes an index, which determines the order in which this input is displayed to users. The \"required\" field\nindicates that the \"url\" parameter is mandatory.\n\nOutput Format\nYou can specify the output format of the node to inform users about what to expect from this node.\n\nFor the QR code generation node, the output format is as follows:\n{\n  \"buildship\": {},\n  \"title\": \"Base64 Data URL\",\n  \"description\": \"base64 data URL of the generated QR code image\",\n  \"type\": \"string\",\n  \"properties\": {}\n}\nHere,\n\ndescription: Provides a brief description of the output, which is the base64 data URL of the generated QR code\nimage.\ntype: Indicates that the output is of type \"string.\"\n\nNode Metadata\nNode metadata allows you to provide information about the node's appearance and purpose.\n\nHere's an example of metadata for the QR code generation node:\n{\n  \"icon\": {\n    \"svg\": \"<path d=\\\"M15 21h-2v-2h2v2zm-2-7h-2v5h2v-5zm8-2h-2v4h2v-4zm-2-2h-2v2h2v-2zM7 12H5v2h2v-2zm-2-2H3v2h2v-2zm7-5h2V3h-2v2zm-7.5-.5v3h3v-3h-3zM8 9H4c-.55 0-1-.45-1-1V4c0-.55.45-1 1-1h4c.55 0 1 .45 1 1v4c0 .55-.45 1-1 1zm-3.5 7.5v3h3v-3h-3zM8 21H4c-.55 0-1-.45-1-1v-4c0-.55.45-1 1-1h4c.55 0 1 .45 1 1v4c0 .55-.45 1-1 1zm8.5-16.5v3h3v-3h-3zM20 9h-4c-.55 0-1-.45-1-1V4c0-.55.45-1 1-1h4c.55 0 1 .45 1 1v4c0 .55-.45 1-1 1zm-1 10v-3h-4v2h2v3h4v-2h-2zm-2-7h-4v2h4v-2zm-4-2H7v2h2v2h2v-2h2v-2zm1-1V7h-2V5h-2v4h4zM6.75 5.25h-1.5v1.5h1.5v-1.5zm0 12h-1.5v1.5h1.5v-1.5zm12-12h-1.5v1.5h1.5v-1.5z\\\"></path>\",\n    \"type\": \"SVG\"\n  },\n  \"name\": \"Generate QR Code\",\n  \"description\": \"Generates a QR code for the given URL and returns the QR code's URL\",\n  \"id\": \"generate-qr-code\"\n}\nHere,\n\nicon: The node's icon, represented as an SVG path. It's defined in the SVG format.\nname: The name of the node, which is \"Generate QR Code\" in this case.\ndescription: A brief description of the node's purpose.\nid: A unique identifier for the node, which can be useful for the Save to Library feature coming soon! üöÄ\n\nThis metadata helps users quickly identify the node and understand its purpose.API / HTTP CallGenerate with AI"
  },
  {
    "title": "Using Variables ‚Äì BuildShip",
    "url": "https://docs.buildship.com/basics/variables",
    "html": "Using Variables in Workflows\nLearn how to use context variables, HTTP request components, and output values from other nodes in your workflow logic.\nUsing Incoming HTTP Request Components\n‚ö†Ô∏èThis is only applicable while using REST API Trigger node.\nWhen working with the REST API Call Trigger, you can leverage various request components like Headers, Params,\nand the Request Body to efficiently pass data to your logic nodes.\nAccessing Request Variables\n\nUse the \"Expression Editor\" to select the request variables.\n\n\nInside the Expression Editor, click on \"Insert Variable\" dropdown to browse and select from the available\nrequest variables.\n\n\n\nüí°Extracting a specific value from a Request VariableLet's consider an example where we want to retrieve the collectionName variable from the request body. To do this, we\ncan:\nIn the Expression Editor, pick the Request Body variable from the \"Insert Variable\" dropdown.\nTo access the specific value, add the key in one of the following formats: - [\"collectionName\"] - .collectionName\n\n\n\nUsing Output values from other nodes\nWhen you have previously returned values from your logic nodes, you can access them conveniently through the\nExpression Menu (x). To access a specific output, click on the name of the node associated with the desired\noutput, and then select your output variable. This allows you to conveniently leverage the output values in your\ncurrent workflow logic.\nNode OutputReordering Nodes"
  },
  {
    "title": "Firebase Full Text Search üîé ‚Äì BuildShip",
    "url": "https://docs.buildship.com/tutorials/firebase-full-text-search",
    "html": "Firebase Full Text Search üîé\n\nCloud Firestore does not natively support indexing or searching text fields in documents. To enable full-text search\nfunctionality in your Firebase project, we recommend integrating with a third-party search integrations like\nAlgolia (opens in a new tab), Elastic (opens in a new tab), or\nTypesense (opens in a new tab), which provide powerful and efficient search capabilities.\nThe integration involves two main steps:\n\nInstalling the Firebase Extension\n\nChoose a third-party search service that suits your requirements, such as Algolia, Elastic, or Typesense.\nEach service may have its own extension for Firebase.\nThese Firebase extensions help in indexing your data and syncing it with the third-party search service everytime a CRUD\noperation is performed on your Firebase data. This helps reduce the cost of indexing and syncing your data.\nüìöGet your Firebase Extensions here!Firebase Extensions are pre-packaged solutions that you can install with a single click. Click on the links below to\ninstall the Firebase Extensions for your preferred search service:\nAlgolia (opens in a new tab)\nElastic (opens in a new tab)\nTypesense (opens in a new tab)\n\n\nNode for Performing a Full-Text Search on the Search Index\n\nThis node allows you to execute full-text search queries on the data stored in the respective search index.\nImplementing Full Text Search\nLet's take a look at how to implement full-text search on your Firebase data. For this example we'll be using Algolia.\nSet up Algolia\n\nGo to Algolia's website (opens in a new tab) and either log in to your existing Algolia account or create a new\none if you don't have an account yet.\n\n\nClick on \"New Application\" and provide a name for your application. Choose an appropriate subscription plan and select\na region for your data center.\n\n\nAfter creating the application, navigate to the \"Indices\" section. Create a new index and give it a name. You can keep\nthe index name the same as your Firestore collection name for simplicity.\n\nGet Algolia KeysTo perform the Full Text Search on your Firebase data, we will be using Algolia's API. To use the API, we need to get\nthe API Key, App ID, and Index Name from Algolia's Dashboard.\n\nGo to the API Keys section (opens in a new tab) in Algolia's Dashboard and copy the API\nKey and App ID.\n \n\n\n\nGo to the Data Sources > Indices section (opens in a new tab) in Algolia's Dashboard and\ncopy the Index Name.  \n\n\nInstall the Algolia Firebase ExtensionTo sync your Firebase collection with Algolia's index, we need to install the\nAlgolia Firebase Extension (opens in a new tab).\n\nClick on the \"Install in Firebase\" button. This will open the Firebase Console in a new tab.\n\n\n\nSelect the Firebase project in which you want to install the extension. If you don't have a Firebase project, you can\ncreate a new one.\n\n\nProceed with the installation.You would be required to add your Algolia API Key, App ID, and Index Name to the node,\ndescribed in the previous section. Click on the \"Install\" button.\n\n\n\nThis would take approximately 3-5 minutes to install on your Firebase project.\n\nPerform Full-Text SearchTo perform a full-text search on the Algolia index, we need to use the \"Algolia Full Text Search\" Node from the Node\nExplorer. You can find this node under the \"Algolia\" category. This node performs a full text search on an Algolia\nindex and returns a JSON object or an array of JSON objects. \nYou would be required to add your Algolia API Key, App ID, and Index Name to the node, described in the\nprevious section.\n‚úÖStore your keys in the Secret Manager The API Key is a sensitive piece of information and should not be shared\npublicly. Make sure you keep your API Key secure and do not share it with anyone. Learn how to store your API Keys as\nsecrets here.\nThe Query input parameter is the search query that you want to execute on the Algolia index.\nYou can add this node to your workflow to perform a full-text search on the Algolia index with your Firebase data.\nThis is how you can perform a full-text search on your Firebase data using Algolia. You can use the same steps to\nperform a full-text search on your Firebase data using Elastic or Typesense.\nYou can find the Full Text Search Nodes for each of these integrations under their respective categories in the Node\nExplorer.TutorialsTriggers"
  },
  {
    "title": "Postgres Integration with BuildShip ‚Äì BuildShip",
    "url": "https://docs.buildship.com/tutorials/postgres",
    "html": "Postgres Integration with BuildShip\n\nBuildShip offers a seamless integration with PostgreSQL using BuildShip's pre-built Postgres Integration nodes, enabling\nyou to perform Create, Read, Update, and Delete (CRUD) operations on your database effortlessly.\n\nYou can find the Postgres Integration nodes under the Integrations section of the node explorer.\nPrerequisites ‚úÖ\nBefore you get started with integrating PostgreSQL into BuildShip, ensure you have the following:\nPostgreSQL Database\nYou should have access to a PostgreSQL database. If you don't have one, you can set it up easily. You can host your\nPostgreSQL database using various providers and methods, including:\n\nSelf-Hosted: You may have a self-hosted PostgreSQL database on your own server or infrastructure.\nCloud-Based: PostgreSQL can be hosted on cloud platforms like AWS RDS, Google Cloud SQL, or Azure Database for\nPostgreSQL.\nServerless: Consider using a serverless PostgreSQL service like NEON (opens in a new tab) (which is used in\nthis tutorial as an example) for a hassle-free and scalable database setup.\n\n\nConnection String Parameters\nRetrieve the connection string parameters for your PostgreSQL database. You'll need the following:\n\nHost: The host of your PostgreSQL database.\nDatabase Name: The name of your PostgreSQL database.\nUser: The username to access your PostgreSQL database.\nPassword: The password associated with the user.\n\n\nLet's walk through with an example of how you can use these nodes to perform CRUD operations on your PostgreSQL\ndatabase. In this example, we'll be using a PostgreSQL database hosted on NEON (opens in a new tab). On BuildShip,\nwe can begin with a new workflow with any Trigger of your preference. In this example, we'll be using a\nREST API Trigger.\nFetching Table Schema\n\nTo fetch the schema of a table in your PostgreSQL database, you can use the Fetch Postgres Table Schema node. Open\nthe Node Explorer, under the Integrations section, select the Postgres category, and select the Fetch Postgres\nTable Schema node to be added to the workflow.\nAdd in your PostgreSQL database's connection string parameters and the table name as input. You can also open\nthe Node Editor (by clicking on the </> icon) to test and modify the existing node.\nüí°Using Secrets to store passwordsIt's always a good practice to use the Secrets to store your database's connection string password or other\nsensitive data. You can then use the Secrets node to retrieve the values of the secrets and use them as inputs for\nthe Postgres Integration nodes. Learn more about using Secrets in BuildShip.\nSample Output:\n\n[\n  {\n    \"column_name\": \"breed_id\",\n    \"data_type\": \"integer\",\n    \"character_maximum_length\": null\n  },\n  {\n    \"column_name\": \"breed_name\",\n    \"data_type\": \"character varying\",\n    \"character_maximum_length\": 100\n  },\n  {\n    \"column_name\": \"origin\",\n    \"data_type\": \"character varying\",\n    \"character_maximum_length\": 100\n  },\n  {\n    \"column_name\": \"average_weight\",\n    \"data_type\": \"numeric\",\n    \"character_maximum_length\": null\n  }\n]\nFetching Table Data\n\nTo fetch the data of a table in your PostgreSQL database, you can use the Fetch Postgres Table Data node from the\nNode Explorer. You can also use a parameterized query to fetch data based on a condition. The Condition Column and\nCondition Value inputs are optional. If you don't provide these inputs, the node will fetch all the data from the\ntable.\nAdd in your PostgreSQL database's connection string parameters and the table name as input. Test and modify the\nnode via the Node Editor (by clicking on the </> icon).\nLet's say we need to fetch the data for the breed_name Doberman Pinscher from the dog_breeds table. We'll add the\nconditionColumn as breed_name and conditionValue as Doberman Pinscher.\nExample Output:\n\n[\n  {\n    \"breed_id\": 2,\n    \"breed_name\": \"German Shepherd\",\n    \"origin\": \"Germany\",\n    \"average_weight\": \"75.00\"\n  }\n]\nInserting Data\n\nTo insert data into a table in your PostgreSQL database, you can use the Insert Data into Postgres DB node from the\nNode Explorer.\nLet's say we need to insert a new row into the dog_breeds table with the following data:\n[\n  {\n    \"breed_id\": 8,\n    \"breed_name\": \"Doberman Pinscher\",\n    \"origin\": \"Germany\",\n    \"average_weight\": 75\n  },\n  {\n    \"breed_id\": 9,\n    \"breed_name\": \"Shih Tzu\",\n    \"origin\": \"Tibet\",\n    \"average_weight\": 12\n  }\n]\nAdd in your PostgreSQL database's connection string parameters and the table name as input. Test and modify the\nnode via the Node Editor (by clicking on the </> icon).\nOutput:\n\nUpdating Data\n\nTo update data in a table in your PostgreSQL database, you can use the Update Postgres Row Data node from the Node\nExplorer.\nLet's say we need to update the average_weight of the Doberman Pinscher breed to 80 in the dog_breeds table.\nAdd in your PostgreSQL database's connection string parameters and the table name as input. The Column ID\nand Column Value let's you filter the row to be updated.\nLet's add the columnId as breed_name and columnValue as Doberman Pinscher. For the data to be updated, we'll add\nthe following JSON in the Data input:\n{\n  \"average_weight\": 80\n}\nOutput:\n\n\nDeleting Data\n\nTo delete data from a table in your PostgreSQL database, you can use the Delete Row from Postgres node from the Node\nExplorer.\nLet's say we need to delete the dog breed which is originated from Tibet from the dog_breeds table.\nAdd in your PostgreSQL database's connection string parameters and the table name as input. The Column ID\nand Column Value let's you filter the row to be deleted.\nAdd the columnId as origin and columnValue as Tibet.\n‚ö†Ô∏èBy default, a DELETE query will remove only one row when there are multiple rows that match the condition.If you want to delete all rows with a specific value in a column, including duplicates, you can use a more specific\ncondition that identifies all the rows you want to delete. You can also modify the query to use a subquery that selects\nall rows with the specified value in a column.\nOutput:\n\n\n\nYou can also create your own Postgres Integration nodes using the versatile Script Node available in the Core\nNodes section of the Node Exporer or, generate it via AI.\n\n\nIf you have any special node requests for us, do let us know via the Support Section on the BuildShip app or,\ndrop us an email with your use case. üôå\nTutorialsTriggers"
  },
  {
    "title": "Storing Files using GCP File Storage ‚Äì BuildShip",
    "url": "https://docs.buildship.com/tutorials/gcp-storage",
    "html": "Storing Files using GCP File Storage\n\nBuildShip simplifies the process of storing files and performing operations on them by offering pre-built Storage\nnodes designed to work seamlessly with GCP Cloud Storage.\nWith these nodes, you can effortlessly manage your files, including tasks such as uploading, creating, deleting, moving,\nand renaming files and folders within your GCP Bucket.\n\nThe integration of BuildShip and GCP Cloud Storage is particularly valuable for users who need a reliable and scalable\nfile storage solution. Whether you're generating AI images or handling other data, BuildShip's pre-built nodes ensure\nthat your files are stored securely and are readily accessible for further processing and sharing.\nUse Cases\nGCP Cloud Storage in BuildShip caters to a diverse range of day-to-day use cases.\nConsider a scenario where you've employed a popular AI Image Generation model like \"Replicate: Stability AI Image\nGeneration.\" Models like these often generate images with short-lived links, making it imperative to store these images\nbefore sharing them.\n\nIn such cases, the storage nodes in BuildShip offer a solution. By providing the external URL, these nodes save your\nimages to your GCP bucket and generate permanent public URLs for easy and secure access by anyone.\nThe use cases extend beyond image generation to encompass any situation where secure and efficient file storage is\nrequired. Whether you're managing data for machine learning models, archiving documents, or sharing resources with your\nteam, BuildShip's integration with GCP Cloud Storage streamlines the process.\nOptions for Storing your Files\nBuildShip provides flexible options for storing files and images to suit your specific needs:\nUse BuildShip's GCP Project\nBuildShip's GCP Project is a convenient option for users who want to get started quickly. This option is ideal for users\nwho don't have a GCP account or don't want to create one.\n\n\nNo Extra Setup Required: Begin using BuildShip's pre-built Storage nodes under the \"BuildShip File Storage\"\ncategory without the need for additional configuration.\nUtilize the Underlying GCP Project: Enjoy the benefits of GCP's robust infrastructure without the hassle of\nsetting it up yourself.\nGenerous Storage Options: BuildShip offers generous storage options that can be upgraded as your needs grow. For\npricing details, visit BuildShip Pricing (opens in a new tab).\nAccess Storage using BuildShip's Built-in Storage UI: Easily manage and access your stored files within the\nBuildShip environment, thanks to its user-friendly Storage UI.\n\nConnect to your own GCP Project\nBuildShip also provides the option to connect to your own GCP Project. This option is ideal for users who already have a\nGCP account and want to manage their GCP resources independently.\n\n\nManage Your Own Buckets: If you prefer to manage your GCP Buckets independently, BuildShip provides the\nflexibility to connect to your existing GCP Project.\nAccess to GCP: You'll have full access to GCP's powerful features, allowing you to configure and manage your\nstorage resources according to your specific requirements.\n\nConnecting to Your Own GCP Project\nTo integrate your own Google Cloud Platform (GCP) Project with BuildShip, follow these steps:\nAccess BuildShip SettingsNavigate to the Settings section, which is located in the top-left corner of your BuildShip dashboard, next to the\nProject Name.‚ö†Ô∏èAdmin Access Required You need to be the admin of the BuildShip account to access the BuildShip Settings.Under the General tab in BuildShip Settings, you will find information about the underlying Firebase Project ID and\nService Account details.Copy the Service Account details as you will need this information to grant access to your GCP project.üí°Each BuildShip project uses one service account to integrate with external services. Once integrated, you can access\nyour GCP Projects via nodes across any workflow inside your project.Grant Access in Firebase IAM & Admin\n\nOpen a new browser tab or window and go to your Firebase Project's Google Cloud Platform (GCP) Console.\n\n\nNavigate to the IAM & Admin section from the Firebase project's GCP Console.\n\n\nClick on the \"Grant Access\" button to add a new principal.\n\n\nPaste the Service Account details you copied from BuildShip into the \"New Principal\" field.\n\n\nAssign the role of \"Storage Admin\" to the Service Account.\n\n\nHit the \"Save\" button to grant access to the Service Account.\n\n‚úÖIf you've already granted permissions to the BuildShip Runtime Service Account for connecting your Firebase Project,\nclick on the edit icon on the same service account and add the \"Storage Admin\" permission as well. This will enable\nyou to use both Firebase and GCP Nodes in your workflows.Getting your Storage Bucket ID\n\nGo to your Google Cloud Console and navigate to the\n\"Cloud Storage Buckets (opens in a new tab)\" section. Here, you'll see all the buckets\navailable in your GCP Project.\n\n\nYou can either choose an existing bucket or create a new one from here.\n\n\nClick on the name of the bucket you want to use and copy the Bucket ID from this location.\n\nInsert a Google Cloud Storage Node\n\nFrom the Node Explorer within BuildShip, insert a Google Cloud Storage integration node into your workflow.\n\n\nAdd the Bucket ID of your GCP project to which you want to add the data.\n\nüí°All the nodes within BuildShip are well-documented. If you need help with how to add specific inputs or understand the\nfunctionality of a particular node, click on the info icon on the node. This will pop up the documentation for that\nspecific node, which includes links and examples to guide you through the process.TutorialsTriggers"
  },
  {
    "title": "Connecting to your Firebase Project ‚Äì BuildShip",
    "url": "https://docs.buildship.com/tutorials/firebase-project",
    "html": "Connecting to your Firebase Project\n\nBuildShip provides pre-defined nodes for Firestore integration, making it easy to interact with Firebase services within\nyour workflows.\nBuildShip offers two options for interacting with Firebase:\n\nUsing BuildShip's built-in Firestore database\nConnecting to your own Firebase project\n\nOption 1: Using BuildShip's Built-in Firestore Database\nBuildShip comes equipped with a built-in Firestore database that is automatically associated with your BuildShip\nproject.\n\n\nNo Additional Setup: Everything is pre-configured and ready for immediate use.\nEasy Access: Users can directly access and interact with the Firestore database through BuildShip.\nFull Functionality: You can perform all CRUD (Create, Read, Update, Delete) operations and more, making it a\ncomprehensive solution for your Firebase integration needs.\n\n‚ö†Ô∏èPresently, users do not have manual access to the underlying Firestore project; however, we have exciting plans to\nintroduce a UI feature that will enable this in the near future! üöÄ\nUsing BuildShip Database nodes\nIn the Node Explorer, navigate to the \"BuildShip Database\" category. You'll find a range of nodes for various\nFirestore operations. Insert the relevant Firestore integration nodes into your workflow. Customize the nodes by\nproviding the necessary input parameters for your specific use case.\n\nYou do not need to provide any additional information, like the Project ID parameter to use the BuildShip Database\nnodes. You can directly use the nodes to interact with your Firestore database.\n\nOption 2: Connecting to Your Own Firebase Project\nUsers can connect their Firebase projects by providing the Project ID and setting up permissions for the BuildShip\nRuntime Service Account.\nSteps to set up your own Firebase Connection:\nInsert any Firebase Integration NodeFrom the Node Explorer, insert any Firestore integration node into your workflow. Add the required fields to the node and add the Project ID of your Firebase project to which you want to add the data.Access BuildShip SettingsNavigate to the Settings section, found in the top-left corner of your dashboard, next to the Project Name.‚ö†Ô∏èAdmin Access Required You need to be the admin of the BuildShip account to access the BuildShip Settings.Under the General tab in BuildShip Settings, you will find information about the underlying Firebase Project ID\nand Service Account details. Copy the Service Account details as we need this to grant access to your Firebase\nproject.Grant Access in Firebase IAM & Admin\n\nOpen a new browser tab or window and go to your Firebase Project's\nGoogle Cloud Platform (GCP) Console (opens in a new tab).\n‚ö†Ô∏èMake sure you are logged in to the correct Google account that has access to the Firebase project you want to\nconnect to BuildShip. Also, make sure you've selected the correct Firebase project in the GCP Console.\n\n\nNavigate to the IAM & Admin section from the Firebase project's GCP Console.\n\n\nClick on the Grant Access button to add a new principal.\n\n\nPaste the Service Account details you copied from BuildShip into the \"New Principal\" field.\n\n\nAssign the role of Cloud Datastore User to the Service Account.\n\n\nHit the Save button to grant access to the Service Account.\n\nThis will allow BuildShip to interact with your Firebase resources.Once you've added the Project ID in your BuildShip Firebase node, you're good to go! üöÄ You can now use the workflow to\ninteract with your Firebase project's data.\nPurpose and Corresponding Nodes\nHere's a comparison table highlighting the purpose of Firestore operations and the corresponding nodes for both\nBuildShip's Firestore Database and your own Firestore Database:\nPurposeBuildShip Database NodesFirestore Database NodesCreate DocumentCreate DocumentCreate Firestore DocumentSync Collection to AlgoliaSync Collection to AlgoliaSync Firebase to Algolia IndexAdd Object to ArrayAdd Object to ArrayAdd Object to Firestore ArrayCollection QueryCollection QueryFirestore Collection QueryQuery CountQuery CountFirestore Query CountDelete DocumentDelete DocumentDelete Firestore DocumentGet DocumentGet DocumentGet Firestore DocumentGet Field ValueGet Field ValueGet Document Field ValueUpdate Field ValueUpdate Field ValueUpdate Firestore Field ValueTutorialsTriggers"
  },
  {
    "title": "Integrate Supabase DB with BuildShip ‚Äì BuildShip",
    "url": "https://docs.buildship.com/tutorials/supabase-crud",
    "html": "Integrate Supabase DB with BuildShip\n\nBuildShip offers a powerful integration with Supabase allowing you to perform Create, Read, Update, and Delete (CRUD)\noperations on your data with ease. This integration is achieved through the Supabase Realtime API.\n\nPrerequisites ‚úÖ\nYour Supabase Table\nA Supabase Table you want to integrate with BuildShip. If you don't have a Supabase project, you can create one at\nsupabase.io (opens in a new tab).\nAPI Key and URL\n\n\nBefore you begin, make sure you have your Supabase API key and Table URL ready. You can obtain these keys from your\nSupabase project dashboard settings:\n\nLog in to your Supabase account.\nNavigate to your project's dashboard.\nIn the dashboard settings, find and copy your API key and Table URL. These keys will be used to connect BuildShip with\nyour Supabase project.\n\nAPI Endpoints (Optional - For creating your own custom nodes)\nYou can get access to API endpoints directly from your table by clicking on the \"API\" button located at the top right\ncorner of the table view. This is useful if you wish to create your own custom nodes for specific endpoints.\nCreating Data\n\nWith BuildShip's integration, you can easily create new records in your Supabase PostgreSQL database. Follow these\nsteps:\n\nIn your BuildShip Workflow, add a Supabase Create Node from the Node Explorer. You can find the Supabase Create Node\nunder the \"Supabase\" integration category or you could simply enter Supabase on the search bar.\nConfigure the node by providing your Supabase API Key, Bearer Token, Table URL, and Table Name.\nOpen the Node Editor to test your node.\nAdd the data you want to create in the \"Data\" field in the form of a JSON object. Here's an example of a JSON object\nyou can use to create a new record in your Supabase table:\n\n{\n  \"breed_name\": \"Birman\",\n  \"country_of_origin\": \"Burma\"\n}\n\nTest your node by clicking on the \"Test\" button. If the node is configured correctly, you should see a new record in\nyour Supabase table.\nOptionally, you could modify and customize the node according to your needs. Once you're done, click on the \"Save\"\nbutton to save your node.\nAdd more nodes or simply add a Return node to complete your workflow.\n\nReading Data\n\nTo retrieve data from your Supabase database, use the Read Node:\n\nIn your BuildShip workflow, add a Supabase Read Node from the Node Explorer. You can find the Supabase Create Node\nunder the \"Supabase\" integration category or you could simply enter Supabase on the search bar.\nConfigure the node by providing your Supabase API Key, Bearer Token, Table URL, and Table Name.\nSpecify the columns you want to retrieve from your table in the \"Columns\" field. You can also leave it empty which\nwill by default retrieve all columns.\nOptionally you could customize, test and save the node.\nExecute the workflow, and BuildShip will fetch the data from your Supabase database in real-time.\nNow you can use this data anywhere in your workflow via the Expressions menu.\n\nUpdating Data\n\nUpdating records in your Supabase database is straightforward with the Update Node:\n\nIn your BuildShip workflow, add a Supabase Update Node from the Node Explorer.\nConfigure the node by providing your Supabase API Key, Bearer Token, Table URL, and Table Name.\nYou need to add conditions to specify which records should be updated using filters like eq, lt, and is.\n\nüí°Refer to the Filters section below for more information on how to use filters.\n\nYou can optionally customize, test and save the node.\nDeploy your workflow, and everytime your workflow triggers, your data will be updated in your Supabase database in\nreal-time.\n\nDeleting Data\n\nTo delete records from your Supabase database, use the Delete Node:\n\nIn your BuildShip workflow, add a Supabase Delete Node from the Node Explorer.\nConfigure the node by providing your Supabase API Key, Bearer Token, Table URL, and Table Name.\nAdd filters to specify which records should be deleted using filters like eq, lt, and is.\nüí°Refer to the Filters section below for more information on how to use filters.\n\nDeploy your workflow and the specified records will be deleted from your Supabase database in real-time.\n\nFilters\nFilters are used to specify which records should be retrieved, updated, or deleted. You can add multiple filters to a\nnode. Here's a list of all the filters you can use:\n\n\neq (Equal): This operator is used to filter records where a specific field is equal to a given value. For example,\nname=eq.siamese would match records where the name field is equal to \"siamese.\" neq (Not Equal): This operator\nfilters records where a specific field is not equal to a given value. For example, age=neq.5 would match records\nwhere the age field is not equal to 5.\n\n\ngt (Greater Than): Use this operator to filter records where a specific field is greater than a given value. For\ninstance, age=gt.30 would match records where the age field is greater than 30.\n\n\nlt (Less Than): This operator filters records where a specific field is less than a given value. For example,\nprice=lt.10 would match records where the price field is less than 10.\n\n\ngte (Greater Than or Equal To): This operator filters records where a specific field is greater than or equal to a\ngiven value. For example, quantity=gte.100 would match records where the quantity field is greater than or equal\nto 100.\n\n\nlte (Less Than or Equal To): Use this operator to filter records where a specific field is less than or equal to a\ngiven value. For instance, rating=lte.4.5 would match records where the rating field is less than or equal to 4.5.\n\n\nis (IS): This operator is used for comparing fields with specific values or conditions, such as checking if a field\nis null. For example, email=is.null would match records where the email field is null.\n\n\nlike (LIKE): This operator allows you to perform partial string matching. For example, name=like.%John% would\nmatch records where the name field contains \"John\" anywhere in the string.\n\nTutorialsTriggers"
  },
  {
    "title": "Scheduled Interval Trigger ‚Äì BuildShip",
    "url": "https://docs.buildship.com/scheduled-interval",
    "html": "Trigger NodesScheduled IntervalScheduled Interval Trigger\n\nThe Scheduled Interval Trigger node is a versatile feature within BuildShip that facilitates workflow automation at\nregular intervals. With this trigger, you can define specific time intervals and units, allowing you to streamline\ntasks and processes based on your requirements.\n\nHow to Use Scheduled Interval Trigger\nConfiguring the Scheduled Interval Trigger involves the following fields:\n\n\nInterval (Unit in digits): Set the numeric value that represents the interval at which your workflow should\ntrigger.\n\n\nTime Unit: Choose the appropriate time unit (e.g., seconds, minutes, hours) for your interval. This unit\ndefines the duration between successive triggers.\n\n\nSetting up the Scheduled Interval Trigger\nTo set up a Scheduled Interval Trigger in your BuildShip workflow, follow these steps:\nAdd Trigger NodeCreate a new workflow or edit an existing one. Click \"Add Trigger\" and select \"Scheduled Interval\" from the available\ntrigger options.Configure TriggerConfigure the fields within the Scheduled Cron Trigger node. You can choose the desired Interval, and time units for\nyour trigger as given in the above sections.\nü¶æUse Cases for Scheduled Interval TriggerExample 1: Every 30 MinutesInterval: 30Time Unit: MinutesDescription: This setup triggers the workflow every 30 minutes, making it ideal for tasks that need to be performed multiple times within an hour.Example 2: Hourly MaintenanceInterval: 1Time Unit: HoursDescription: This configuration triggers the workflow every hour, allowing you to automate routine maintenance tasks.Scheduled CronRowy Trigger"
  },
  {
    "title": "Telegram Bot Trigger ‚Äì BuildShip",
    "url": "https://docs.buildship.com/telegram-bot",
    "html": "Trigger NodesTelegram BotTelegram Bot Trigger\n\nThe Telegram Bot is a handy trigger within BuildShip that enables you to **handle incoming messages in Telegram chat\nor Telegram group with a visual workflow builder.\nThis trigger allows you to easily manage Telegram groups, moderate and respond with meaningful messages and even include\nOpenAI in your workflow to generate meaningful responses to assist users in your group.\n\nPre-requisites ‚úÖ\n\nTelegram bot API key - The API keys of the Telegram bot that will be responding to the incoming messages. To\nsetup a bot and get the API key, follow the instructions here.\nTelegram group Chat ID - This is the group on which your Telegram bot will operate and listen to messages and\nsend responses to. To learn how setup a group and get chat id, go\nhere.\n\nStep to create a Telegram Bot workflow\nAdd the Telegram Bot TriggerAdd the telegram bot's API Key, that you can get from this step.  Also,\noptionally you can add a Verification Code if you want incoming requests to be verified.  Add \"Send Telegram message\" Node\nNext to you workflow, add a node by searching in the node explorer for \"Send Telegram message\" node to reply to\nincoming messages.\nAdd the \"Chat ID\" of the group that you want the bot to reply to.\nTo this node also add the response \"Text\" that you want the bot to reply with. We have added here, a generic message\nof \"Welcome to the group...\".\nYou can however, add nodes like OpenAI text generation to respond with AI, or even verify if the incoming message is\nfrom a Stripe paying user before responding\nThere is full flexibiliy to add more nodes and handle what your bot is replying with. \n\n\nReturn success status and click ShipFinally, add a \"Return\" node that will respond with a success status. And click the \"Ship\" button to deploy the workflowSend a message to TestFinally, you can send a message and test the response is as expected.That's it üéâThis is a starting point, you can tweak this anyway you like.\nHow to setup a Telegram bot and get API key\n\nEnter @BotFather in the search tab and select the verified bot with tick mark that shows up. \n\n\nClick Start to activate the BotFather bot. You will receive a list of commands to manage the bots.\nChoose or type the /newbot command and click Send.\nChoose a name for your bot. Your subscribers will see it in their conversations. Next, choose a username for your\nbot. The bot can be found by its username in the search bar. The username must be unique and end with the word ‚Äúbot.‚Äù\nOnce you've made your selection for your bot's name, your bot will be brought to life. Shortly thereafter, you'll\nreceive a message containing a link leading to your bot, which can be accessed at \"t.me/[bot_username] as well as\nyour API key.\nMake note of this API key as this is what you will need to use in the Telegram Trigger node on BuildShip. \n\n\n\nHow to setup a Telegram group and get chat id\n\nCreate a group on Telegram\nInvite the bot you created in the previous steps\nAlso search and invite \"RawDataBot\" to your group.  \nOnce you invite this RawDataBot to your group, it will post a message with the Chat ID of this group. Make a note of\nit for use in the Step 2 of your Telegram workflow.\n\n\n\n\n\n\nüôãüèªNeed help? Chat with us and our community of low-code/no-code builders and developers on\nDiscord (opens in a new tab).Rowy TriggerBranch (If Else)"
  },
  {
    "title": "REST API Call Trigger ‚Äì BuildShip",
    "url": "https://docs.buildship.com/rest-api",
    "html": "Trigger NodesRest APIREST API Call Trigger\nWith this powerful trigger node, you can initiate automation by sending HTTP requests to specified URL endpoints.\nWhen setting up the REST API Call Trigger, you define the path, choose the HTTP method (GET, PUT, POST, DELETE),\nand create the complete endpoint URL.\n\nSetting up a REST API Call Trigger in BuildShip\nTo set up a REST API Call Trigger in your BuildShip workflow, follow these steps:\nAdd Trigger NodeIn a fresh workflow, click \"Add Trigger,\" and select \"Rest API Call\" from the available options. The Rest API Call trigger comes with three fields:\nPath: Specify the URL Endpoint to which you want to send the request.\nMethod: Choose the appropriate HTTP method for your request, such as GET, PUT, POST, or DELETE.\nEndpoint URL: This is the complete request URL, including the endpoint you specified in the Path field.\nPlatform to send RequestsThe REST API Call Trigger allows you to pick any platform to trigger an HTTP request to the specified Endpoint URL. This\nflexibility empowers you to integrate BuildShip with various applications and services seamlessly.\nExample: Triggering a Workflow with a REST API Call\nCalculator - Multiplying two numbers and returning the result\nNODE 1: Trigger - Rest API Call\nSet path to /calculator\nMethod: POST\nCopy the endpoint URL\nNODE 2: Calculator Node\nSelected a pre-built Calculator Node from the Node Library.\nTo add first and second numbers, click on the Expression (x) icon ‚Üí Select Expression ‚Üí Click on the\nExpression Editor ‚Üí Click on Insert Variable ‚Üí Under Request, select Body and add the key in either of\nthe following formats: [\"num1\"] or .num1.\nRepeat the above step for the second number.\nSelected the operation as MULTIPLY.\nNODE 3: Return Node\nAdded a pre-built Return Node from the Node Library.\nSet the Status Code to (OK) 200\nFor the Value, click on the Expression (x) icon ‚Üí Select Expression ‚Üí Click on the Expression Editor ‚Üí Click on\nInsert Variable ‚Üí Under Calculator, select Result.\nTesting the WorkflowTo test our our Workflow, let‚Äôs go to Postman. Add in the copied Endpoint URL and set the request method to POST. (Same\nas we had set up in the Trigger Node)Add in the body and click Send! üöÄReordering NodesScheduled Cron"
  },
  {
    "title": "Scheduled Cron Trigger ‚Äì BuildShip",
    "url": "https://docs.buildship.com/scheduled-cron",
    "html": "Trigger NodesScheduled CronScheduled Cron Trigger\n\nThe Scheduled Cron Trigger node is a powerful tool within BuildShip that enables you to automate workflows based on\nscheduled time intervals. This trigger allows you to initiate workflows at specific times, or patterns, ensuring\ntimely execution of your automation tasks.\n\nHow to Use Scheduled Cron Trigger\nThe Scheduled Cron Trigger node comes with three essential fields that you need to configure:\n\n\nLocation: The GCP region where the trigger will be executed. This field is automatically filled based on the\nGCP region associated with your workspace.\n\n\nSchedule: Set the schedule pattern using the cron syntax. This field determines the frequency and timing of\nyour workflow execution. For example, */20 * * * * specifies an interval of 20 minutes.\n\n\nüí°Discover additional information about cron syntax and creating custom cron expressions\nhere.\n\nTime Zone: Choose the desired time zone for your scheduled trigger. You can select from the list of existing\ntime zones.\n\nUnderstanding the Cron Syntax\nCRON syntax is a widely used standard for scheduling tasks in various Unix-like operating systems. It defines a set\nof fields that specify when a task should be executed based on time intervals. Each field represents a unit of time,\nallowing users to define intricate scheduling patterns.\n\nThe CRON syntax consists of five fields, each separated by a space:\n\n\nMinute (0 - 59): Specifies the minute at which the task should run. A value of * indicates any minute, while 0\nindicates the exact minute.\n\n\nHour (0 - 23): Specifies the hour at which the task should run. A value of * indicates any hour, while 0\nindicates midnight.\n\n\nDay of Month (1 - 31): Specifies the day of the month when the task should run. A value of * indicates any day,\nwhile specific numbers represent particular days.\n\n\nMonth (1 - 12): Specifies the month when the task should run. A value of * indicates any month, while specific\nnumbers represent particular months.\n\n\nDay of Week (0 - 6): Specifies the day of the week when the task should run. The values 0 and 7 often represent\nSunday, 1 represents Monday, and so on.\n\n\nThe CRON syntax also supports special characters and shorthand notations:\n\n*/x: Represents every x interval. For example, */15 in the minutes field means every 15 minutes.\nx-y: Represents a range of values. For example, 1-5 in the day of week field means Monday to Friday.\nx,y,z: Represents a list of values. For example, 1,15 in the day of month field means the 1st and 15th day.\n\n‚úÖEXAMPLE 1: Suppose you want to schedule a task to run every day at 3:30 PM.The CRON expression for this scenario would be: 30 15 * * *\nMinute (30): The task should run at the 30th minute of the hour.\nHour (15): The task should run at the 15th hour, which is 3:00 PM in 24-hour format.\nDay of Month (*): The task should run on any day of the month.\nMonth (*): The task should run in any month.\nDay of Week (*): The task should run on any day of the week.\n\n‚úÖEXAMPLE 2: Suppose you want to schedule a task to run every weekday (Monday to Friday) at 9:00 AM.The CRON expression for this scenario would be: 0 9 * * 1-5\nMinute (0): The task should run at the 0th minute of the hour.\nHour (9): The task should run at the 9th hour, which is 9:00 AM.\nDay of Month (*): The task should run on any day of the month.\nMonth (*): The task should run in any month.\nDay of Week (1-5): The task should run on Monday to Friday.\n\nSetting up the Scheduled Cron Trigger\nTo set up a Scheduled Cron Trigger within your BuildShip workflow, follow these steps:\nAdd Trigger NodeCreate a new workflow or open an existing one. Click \"Add Trigger\" and select \"Scheduled Cron\" from the available\ntrigger options.Configure FieldsConfigure the fields within the Scheduled Cron Trigger node. You can choose the desired GCP region, schedule pattern,\nand time zone for your trigger as given in the above sections.\nü¶æUse Cases for Scheduled Interval TriggerExample 1: Daily BackupCRON Expression: 0 0 * * *Description: This expression triggers the workflow every day at midnight. It's perfect for automating daily backups of your data.Example 2: Weekly ReportsCRON Expression: 0 8 * * 1Description: This expression triggers the workflow every Monday at 8:00 AM. It's great for generating weekly reports at the start of the workweek.Rest APIScheduled Interval"
  }
]
